{"version":3,"sources":["webpack:///./src/js/Core/Info.js","webpack:///./src/js/Core/Storage/SyncedStorage.js","webpack:///./src/js/setup.js","webpack:///./src/js/Core/Errors/Errors.js","webpack:///./src/js/Core/Html/Html.js","webpack:///./src/js/Core/Html/HtmlParser.js","webpack:///./src/js/Core/Storage/CookieStorage.js","webpack:///./src/js/Core/Environment.js","webpack:///./src/js/Core/Localization/Language.js","webpack:///./src/js/Core/ExtensionResources.js","webpack:///./src/js/Core/Localization/Localization.js","webpack:///./src/js/Core/BackgroundSimple.js","webpack:///./src/js/Core/Permissions.js","webpack:///./src/js/Background/Modules/ContextMenu.js","webpack:///./src/js/Core/Utils/TimeUtils.js","webpack:///./node_modules/idb/build/esm/wrap-idb-value.js","webpack:///./node_modules/idb/build/esm/index.js","webpack:///./src/js/Background/Modules/IndexedDB.js","webpack:///./src/js/Core/Storage/LocalStorage.js","webpack:///./src/js/Core/GameId.js","webpack:///./src/js/Background/Modules/Api.js","webpack:///./src/js/Background/Modules/CacheStorage.js","webpack:///./src/js/Background/Modules/SteamCommunityApi.js","webpack:///./src/js/Background/Modules/SteamStoreApi.js","webpack:///./src/js/Background/Modules/StaticResources.js","webpack:///./src/js/config.js","webpack:///./src/js/Background/Modules/ITADApi.js","webpack:///./src/js/Background/Modules/AugmentedSteamApi.js","webpack:///./src/js/Background/Modules/ExtensionData.js","webpack:///./src/js/Background/background.js"],"names":["browser","runtime","getManifest","version","SyncedStorage","key","Object","prototype","hasOwnProperty","call","this","_cache","defaults","console","warn","value","_adapter","set","entries","remove","prefix","keys","filter","k","startsWith","force","tmp","persistent","reduce","acc","option","clear","import","storage","onChanged","addListener","changes","val","get","assign","onDone","onCatch","init","then","JSON","stringify","QUOTA_BYTES_PER_ITEM","sync","local","freeze","Promise","finally","defineProperty","callback","constructor","resolve","reason","error","initialized","LoginError","Error","type","super","name","ServerOutageError","msg","HTTPError","code","message","FeatureDependencyError","featureName","Errors","HTML","str","map","replace","m","html","template","document","createElement","innerHTML","DOMPurify","sanitize","content","fragment","firstElementChild","node","_node","querySelector","Element","_getNode","outerHTML","wrapper","element","replaceWith","append","position","insertAdjacentHTML","adjacent","HTMLParser","string","text","regex","RegExp","match","parseInt","parse","dom","querySelectorAll","getVariableFromText","textContent","CookieStorage","defaultValue","_name","trim","cache","has","ttl","_val","encodeURIComponent","cookie","delete","Map","split","kv","decodeURIComponent","ContextType","currentContext","extension","getBackgroundPage","bgPage","window","BACKGROUND","OPTIONS","CONTENT_SCRIPT","Language","_currentSteamLanguage","script","language","URL","src","searchParams","isContentScript","languages","array","includes","getCurrentSteamLanguage","ExtensionResources","pathname","getURL","fetch","r","json","Localization","getJSON","_promise","currentSteamLanguage","storedSteamLanguage","deepAssign","target","source","sendMessage","requested","params","length","action","getLanguageCode","codes","push","all","lc","loadLocalization","english","path","reverse","current","pop","PermissionOptions","Permissions","permissionList","permissions","contains","request","contextMenus","removeAll","permission","onAdded","onRemoved","p","optionToRemove","unusedPermissions","_getUnusedPermissions","used","Set","setup","add","unused","Array","from","values","ContextMenu","info","query","selectionText","url","queryLinks","menuItemId","steamKeys","alert","options","no_keys_found","steamKey","tabs","create","chrome","lastError","build","Timer","duration","_id","setTimeout","onSuccess","onFail","clearTimeout","ResettableTimer","reset","_running","async","TimeUtils","Math","trunc","Date","now","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","prop","receiver","IDBTransaction","objectStoreNames","undefined","objectStore","transformCachableValue","func","IDBDatabase","transaction","IDBCursor","advance","continue","continuePrimaryKey","args","apply","unwrap","storeNames","tx","sort","done","reject","unlisten","removeEventListener","complete","DOMException","addEventListener","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","promise","success","result","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","method","storeName","store","index","shift","returnVal","oldTraps","IndexedDB","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","db","openDB","createObjectStore","createIndex","deleteIndex","_deleteOldData","expiryStore","cursor","openCursor","IDBKeyRange","upperBound","expired","stores","promises","primaryKey","expiryKey","dataStore","timestampedStores","strKeyPromise","nmbKey","Number","data","multiple","expiry","expiryKeys","cached","cacheObjectStores","timestampedEntry","timestampedEntriesStores","nonAssociativeData","autoIncrement","keyPath","put","_ttl","isArray","forEach","expiryTx","_asArray","checkStoreExpiry","checkEntryExpiry","_resultsAsObject","getAllKeys","indexName","asKey","getKey","getAll","openKeyCursor","Boolean","dataPromise","clearPromise","bound","String","fromCharCode","charCodeAt","isExpired","preventFetch","dataTx","fetchUpdatedData","requestKey","_ongoingRequests","req","timestampedStore","objStoreFetchFns","group","err","groupEnd","i","LocalStorage","item","localStorage","getItem","setItem","removeItem","GameId","id","_text","HTMLElement","appid","dataset","dsAppid","parseId","href","subid","dsPackageid","bundleid","dsBundleid","storeId","slice","indexOf","res","exec","Api","endpoint","origin","_params","body","formData","FormData","v","responseHandler","_endpoint","endsWith","response","_fetchWithDefaults","objPath","getEndpoint","part","mapFn","CacheStorage","timestamp","substring","SteamCommunityApi","border","getPage","contextId","login","lastAssetid","thisParams","steamId","status","assets","concat","descriptions","last_assetid","more_items","coupons","getInventory","description","actions","coupon","icon_url","classid","instanceid","desc","link","packageid","discount","packages","details","appids","getFromIndex","indexContainsKey","gifts","passes","isPackage","addGiftsAndPasses","getAppids","getAppid","market_hash_name","hashes","parser","DOMParser","parseFromString","innerText","size","parseFloat","input","reviewCount","reviews","ceil","doc","headerText","playtimeText","visibilityNode","_getReviewId","rating","helpful","join","funny","visibility","playtime","review","profilePath","self","logout","steamid","newLogout","newCountry","SteamStoreApi","apps","obj","sessionid","sessionId","postEndpoint","clearDynamicStore","_sessionid","htmlToDOM","currency","getAttribute","currencyFromWallet","currencyFromApp","lang","replaceRegex","purchaseDates","nodes","nextElementSibling","removeNode","appName","clearSpecialSymbols","rgOwnedApps","rgOwnedPackages","rgIgnoredApps","rgWishlist","dynamicStore","ids","ownedApps","floor","random","filters","endpointFactory","_progressingRequests","StaticResources","_supportedCurrencies","ITADApi","rnd","crypto","getRandomValues","Uint32Array","redirectURI","authUrl","requiredScopes","tab","toString","webRequestListener","webRequest","onBeforeRequest","removeListener","tabsListener","tabId","hashFragment","hash","URLSearchParams","substr","accessToken","expiresIn","lsEntry","token","resultFn","isConnected","endpointFactoryCached","waitlistJSON","storeids","deleteEndpoint","subids","collectionJSON","_appids","_subids","storeid","lastImport","to","dsKeys","itadImportKeys","removeDuplicates","other","el","ownedPackages","lastOwnedApps","lastOwnedPackages","newOwnedApps","newOwnedPackages","addToCollection","wishlisted","lastWishlisted","newWishlisted","addToWaitlist","games","typemap","collection","gameid","types","_types","waitlist","storeIds","AugmentedSteamApi","metalink","showoc","mcurl","oc","ExtensionData","idbNotes","notes","note","clearNotes","giftsAndPasses","items","fetchWorkshopFileSize","fetchReviews","purchaseDate","fetchPackage","mapCollection","mapWaitlist","actionCallbacks","wishlistAdd","wishlistRemove","currencies","moveNotesToSyncedStorage","getNote","setNote","deleteNote","getAllNotes","setAllNotes","clearCache","storePageData","expireStorePageData","rates","isEA","steamPeek","appDetails","appUserDetails","wishlists","purchases","clearPurchases","dsStatus","dynamicStoreRandomApp","storeCountry","cards","stats","getCoupon","hasGiftsAndPasses","hasCoupon","hasItem","getProfile","clearOwn","getWorkshopFileSize","getReviews","updateReviewNode","authorize","disconnect","inWaitlist","removeFromWaitlist","inCollection","getFromCollection","onMessage","sender","purifyConfig","ADD_ATTR","addHook","attrName","attrValue","setAttribute","keepAttr","setConfig","onStartup","update","onInstalled","when","onClicked","onClick"],"mappings":"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","file":"js/background.js","sourcesContent":["\r\nconst Info = {\r\n    \"version\": browser.runtime.getManifest().version,\r\n    \"db_version\": 3,\r\n};\r\n\r\nexport {Info};\r\n","import {Info} from \"../Info\";\r\n\r\nclass SyncedStorage {\r\n\r\n    /*\r\n     * browser.storage.sync limits\r\n     * QUOTA_BYTES = 102400 // 100KB\r\n     * QUOTA_BYTES_PER_ITEM = 8192 // 8KB\r\n     * MAX_ITEMS = 512\r\n     * MAX_WRITE_OPERATIONS_PER_HOUR = 1800\r\n     * MAX_WRITE_OPERATIONS_PER_MINUTE = 120\r\n     */\r\n    static has(key) {\r\n        return Object.prototype.hasOwnProperty.call(this._cache, key);\r\n    }\r\n\r\n    static get(key) {\r\n        if (typeof this._cache[key] == \"undefined\") {\r\n            if (typeof this.defaults[key] == \"undefined\") {\r\n                console.warn(`Unrecognized SyncedStorage key \"${key}\"`);\r\n            }\r\n            return this.defaults[key];\r\n        }\r\n        return this._cache[key];\r\n    }\r\n\r\n    static set(key, value) {\r\n        this._cache[key] = value;\r\n        return this._adapter.set({[key]: value});\r\n\r\n        // this will throw if MAX_WRITE_*, MAX_ITEMS, QUOTA_BYTES* are exceeded\r\n    }\r\n\r\n    static import(entries) {\r\n        for (const [key, value] of Object.entries(entries)) {\r\n            this._cache[key] = value;\r\n        }\r\n        return this._adapter.set(entries);\r\n    }\r\n\r\n    static remove(key) {\r\n        if (typeof this._cache[key] !== \"undefined\") {\r\n            delete this._cache[key];\r\n        }\r\n        return this._adapter.remove(key);\r\n\r\n        // can throw if MAX_WRITE* is exceeded\r\n    }\r\n\r\n    static keys(prefix = \"\") {\r\n        return Object.keys(this._cache).filter(k => k.startsWith(prefix));\r\n    }\r\n\r\n    static entries() {\r\n        return Object.entries(this._cache);\r\n    }\r\n\r\n    static async clear(force = false) {\r\n\r\n        let tmp;\r\n        if (force) {\r\n            this._cache = {};\r\n        } else {\r\n            tmp = this.persistent.reduce((acc, option) => {\r\n                acc[option] = this._cache[option];\r\n                return acc;\r\n            }, {});\r\n        }\r\n\r\n        // can throw if MAX_WRITE* is exceeded\r\n        await this._adapter.clear();\r\n\r\n        if (!force) {\r\n            await this.import(tmp);\r\n        }\r\n    }\r\n\r\n    // load whole storage and make local copy\r\n    static async init() {\r\n        browser.storage.onChanged.addListener(changes => {\r\n            for (const [key, {\"newValue\": val}] of Object.entries(changes)) {\r\n                this._cache[key] = val;\r\n            }\r\n        });\r\n\r\n        const storage = await this._adapter.get(null);\r\n        Object.assign(this._cache, storage);\r\n\r\n        return this._cache;\r\n    }\r\n\r\n    static then(onDone, onCatch) {\r\n        return this.init().then(onDone, onCatch);\r\n    }\r\n\r\n    static toJson() {\r\n        return JSON.stringify(this._cache);\r\n    }\r\n}\r\n\r\nSyncedStorage.QUOTA_BYTES_PER_ITEM = 8192;\r\n\r\nSyncedStorage._adapter = browser.storage.sync || browser.storage.local;\r\nSyncedStorage._cache = {};\r\nSyncedStorage.defaults = Object.freeze({\r\n    \"language\": \"english\",\r\n\r\n    \"version\": Info.version,\r\n    \"version_show\": true,\r\n\r\n    \"highlight_owned_color\": \"#00ce67\",\r\n    \"highlight_wishlist_color\": \"#0491bf\",\r\n    \"highlight_coupon_color\": \"#a26426\",\r\n    \"highlight_inv_gift_color\": \"#800040\",\r\n    \"highlight_inv_guestpass_color\": \"#513c73\",\r\n    \"highlight_notinterested_color\": \"#4f4f4f\",\r\n    \"highlight_collection_color\": \"#856d0e\",\r\n    \"highlight_waitlist_color\": \"#4c7521\",\r\n\r\n    \"tag_owned_color\": \"#00b75b\",\r\n    \"tag_wishlist_color\": \"#0383b4\",\r\n    \"tag_coupon_color\": \"#c27120\",\r\n    \"tag_inv_gift_color\": \"#b10059\",\r\n    \"tag_inv_guestpass_color\": \"#65449a\",\r\n    \"tag_notinterested_color\": \"#4f4f4f\",\r\n    \"tag_collection_color\": \"#856d0e\",\r\n    \"tag_waitlist_color\": \"#4c7521\",\r\n\r\n    \"highlight_owned\": true,\r\n    \"highlight_wishlist\": true,\r\n    \"highlight_coupon\": false,\r\n    \"highlight_inv_gift\": false,\r\n    \"highlight_inv_guestpass\": false,\r\n    \"highlight_notinterested\": false,\r\n    \"highlight_excludef2p\": false,\r\n    \"highlight_collection\": true,\r\n    \"highlight_waitlist\": true,\r\n\r\n    \"tag_owned\": false,\r\n    \"tag_wishlist\": false,\r\n    \"tag_coupon\": false,\r\n    \"tag_inv_gift\": false,\r\n    \"tag_inv_guestpass\": false,\r\n    \"tag_notinterested\": true,\r\n    \"tag_collection\": false,\r\n    \"tag_waitlist\": false,\r\n    \"tag_short\": false,\r\n\r\n    \"hidetmsymbols\": false,\r\n\r\n    \"showlowestprice\": true,\r\n    \"showlowestprice_onwishlist\": true,\r\n    \"showlowestpricecoupon\": true,\r\n    \"showallstores\": true,\r\n    \"stores\": [],\r\n    \"override_price\": \"auto\",\r\n    \"showregionalprice\": \"mouse\",\r\n    \"regional_countries\": [\"us\", \"gb\", \"ru\", \"br\", \"au\", \"jp\"],\r\n\r\n    \"show_es_homepagetabs\": true,\r\n    \"showmarkettotal\": false,\r\n    \"showsteamrepapi\": true,\r\n    \"showmcus\": true,\r\n    \"showoc\": true,\r\n    \"showhltb\": true,\r\n    \"showyoutube\": true,\r\n    \"showtwitch\": true,\r\n    \"showpcgw\": true,\r\n    \"showcompletionistme\": false,\r\n    \"showprotondb\": false,\r\n    \"showviewinlibrary\": false,\r\n    \"showsteamcardexchange\": false,\r\n    \"showitadlinks\": true,\r\n    \"showsteamdb\": true,\r\n    \"showbartervg\": false,\r\n    \"showastatslink\": true,\r\n    \"showyoutubegameplay\": true,\r\n    \"showyoutubereviews\": true,\r\n    \"showwsgf\": true,\r\n    \"exfgls\": true,\r\n    \"app_custom_link\": [\r\n        {\r\n            \"enabled\": false,\r\n            \"name\": \"Google\",\r\n            \"url\": \"google.com/search?q=[ID]+[NAME]\",\r\n            \"icon\": \"www.google.com/images/branding/product/ico/googleg_lodp.ico\"\r\n        },\r\n    ],\r\n\r\n    \"customize_apppage\": {\r\n        \"recentupdates\": true,\r\n        \"reviews\": true,\r\n        \"about\": true,\r\n        \"contentwarning\": true,\r\n        \"steamchart\": true,\r\n        \"steamspy\": true,\r\n        \"surveys\": true,\r\n        \"sysreq\": true,\r\n        \"legal\": true,\r\n        \"morelikethis\": true,\r\n        \"recommendedbycurators\": true,\r\n        \"customerreviews\": true\r\n    },\r\n\r\n    \"customize_frontpage\": {\r\n        \"featuredrecommended\": true,\r\n        \"specialoffers\": true,\r\n        \"trendingamongfriends\": true,\r\n        \"discoveryqueue\": true,\r\n        \"browsesteam\": true,\r\n        \"curators\": true,\r\n        \"morecuratorrecommendations\": true,\r\n        \"recentlyupdated\": true,\r\n        \"fromdevelopersandpublishersthatyouknow\": true,\r\n        \"popularvrgames\": true,\r\n        \"homepagetabs\": true,\r\n        \"gamesstreamingnow\": true,\r\n        \"under\": true,\r\n        \"updatesandoffers\": true,\r\n        \"homepagesidebar\": true\r\n    },\r\n\r\n    // 'show_keylol_links': false, // not in use, option is commented out\r\n    \"show_package_info\": false,\r\n    \"show_steamchart_info\": true,\r\n    \"show_steamspy_info\": true,\r\n    \"show_early_access\": true,\r\n    \"show_alternative_linux_icon\": false,\r\n    \"show_itad_button\": false,\r\n    \"skip_got_steam\": false,\r\n\r\n    \"installsteam\": \"show\",\r\n    \"openinnewtab\": false,\r\n    \"keepssachecked\": false,\r\n    \"showemptywishlist\": true,\r\n    \"user_notes_app\": true,\r\n    \"user_notes_wishlist\": true,\r\n    \"showwishliststats\": true,\r\n    \"user_notes\": {},\r\n    \"user_notes_adapter\": \"synced_storage\",\r\n    \"replaceaccountname\": true,\r\n    \"showlanguagewarning\": true,\r\n    \"showlanguagewarninglanguage\": \"english\",\r\n    \"homepage_tab_selection\": \"remember\",\r\n    \"homepage_tab_last\": null,\r\n    \"send_age_info\": true,\r\n    \"removebroadcasts\": false,\r\n    \"mp4video\": false,\r\n    \"horizontalscrolling\": true,\r\n    \"showsupportinfo\": true,\r\n    \"showdrm\": true,\r\n    \"regional_hideworld\": false,\r\n    \"showinvnav\": true,\r\n    \"quickinv\": true,\r\n    \"quickinv_diff\": -0.01,\r\n    \"community_default_tab\": \"\",\r\n    \"showallachievements\": false,\r\n    \"showallstats\": true,\r\n    \"showachinstore\": true,\r\n    \"showcomparelinks\": false,\r\n    \"hideactivelistings\": false,\r\n    \"showlowestmarketprice\": true,\r\n    \"hidespamcomments\": false,\r\n    \"spamcommentregex\": \"[\\\\u2500-\\\\u25FF]\",\r\n    \"wlbuttoncommunityapp\": true,\r\n    \"removeguideslanguagefilter\": false,\r\n    \"disablelinkfilter\": false,\r\n    \"sortfriendsby\": \"default_ASC\",\r\n    \"sortreviewsby\": \"default_ASC\",\r\n    \"sortgroupsby\": \"default_ASC\",\r\n    \"show1clickgoo\": true,\r\n    \"show_profile_link_images\": \"gray\",\r\n    \"show_custom_themes\": true,\r\n    \"profile_steamrepcn\": true,\r\n    \"profile_steamgifts\": true,\r\n    \"profile_steamtrades\": true,\r\n    \"profile_bartervg\": true,\r\n    \"profile_steamrep\": true,\r\n    \"profile_steamdbcalc\": true,\r\n    \"profile_astats\": true,\r\n    \"profile_backpacktf\": true,\r\n    \"profile_astatsnl\": true,\r\n    \"profile_steamid\": true,\r\n    \"profile_custom_link\": [\r\n        {\r\n            \"enabled\": true,\r\n            \"name\": \"Google\",\r\n            \"url\": \"google.com/search?q=[ID]\",\r\n            \"icon\": \"www.google.com/images/branding/product/ico/googleg_lodp.ico\"\r\n        },\r\n    ],\r\n    \"fav_emoticons\": [],\r\n    \"group_steamgifts\": true,\r\n    \"steamcardexchange\": true,\r\n    \"purchase_dates\": true,\r\n    \"show_badge_progress\": true,\r\n    \"show_coupon\": true,\r\n    \"show_wishlist_link\": true,\r\n    \"show_wishlist_count\": true,\r\n    \"show_progressbar\": true,\r\n    \"show_backtotop\": false,\r\n\r\n    \"profile_showcase_twitch\": true,\r\n    \"profile_showcase_own_twitch\": false,\r\n    \"profile_showcase_twitch_profileonly\": false,\r\n\r\n    \"itad_import_library\": false,\r\n    \"itad_import_wishlist\": false,\r\n    \"add_to_waitlist\": false,\r\n\r\n    \"context_steam_store\": false,\r\n    \"context_steam_market\": false,\r\n    \"context_itad\": false,\r\n    \"context_bartervg\": false,\r\n    \"context_steamdb\": false,\r\n    \"context_steamdb_instant\": false,\r\n    \"context_steam_keys\": false,\r\n});\r\nSyncedStorage.persistent = [\r\n    \"user_notes\",\r\n    \"user_notes_adapter\",\r\n];\r\n\r\nexport {SyncedStorage};\r\n","import {SyncedStorage} from \"./Core/Storage/SyncedStorage\";\r\n\r\n/*\r\n * Shim for Promise.finally() for browsers (Waterfox/FF 56) that don't have it\r\n * https://github.com/domenic/promises-unwrapping/issues/18#issuecomment-57801572\r\n */\r\nif (typeof Promise.prototype.finally === \"undefined\") {\r\n    // eslint-disable-next-line no-extend-native\r\n    Object.defineProperty(Promise.prototype, \"finally\", {\r\n        \"value\": function(callback) {\r\n            const constructor = this.constructor;\r\n            return this.then((value) => {\r\n                return constructor.resolve(callback()).then(() => {\r\n                    return value;\r\n                });\r\n            }, (reason) => {\r\n                return constructor.resolve(callback()).then(() => {\r\n                    console.error(reason);\r\n                    throw reason;\r\n                });\r\n            });\r\n        },\r\n    });\r\n}\r\n\r\nlet initialized = false;\r\n\r\n/**\r\n * DOMPurify setup\r\n * @see https://github.com/cure53/DOMPurify\r\n */\r\nexport default function() {\r\n\r\n    if (initialized) { return; }\r\n    initialized = true;\r\n\r\n    const allowOpenInNewTab = SyncedStorage.get(\"openinnewtab\");\r\n\r\n    /*\r\n     * NOTE FOR ADDON REVIEWER:\r\n     * We are modifying default DOMPurify settings to allow other protocols in URLs\r\n     * and to allow links to safely open in new tabs.\r\n     *\r\n     * We took the original Regex and aded chrome-extension://, moz-extension:// and steam://\r\n     * First two are needed for linking local resources from extension,\r\n     * steam:// protocol is used by Steam store to open their own client (e.g. when you want to launch a game).\r\n     *\r\n     * The addition of the `target` attribute to the allowed attributes is done in order to be able to open links in a new tab.\r\n     * We only allow target=\"_blank\" while adding rel=\"noreferrer noopener\" to prevent child window to access window.opener\r\n     * as described in https://www.jitbit.com/alexblog/256-targetblank---the-most-underestimated-vulnerability-ever/\r\n     */\r\n\r\n    const purifyConfig = {\r\n        \"ALLOWED_URI_REGEXP\": /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|chrome-extension|moz-extension|steam):|[^a-z]|[a-z+.-]+(?:[^a-z+.\\-:]|$))/i\r\n    };\r\n\r\n    if (allowOpenInNewTab) {\r\n        purifyConfig.ADD_ATTR = [\"target\"];\r\n\r\n        DOMPurify.addHook(\"uponSanitizeAttribute\", (node, data) => {\r\n            if (data.attrName === \"target\") {\r\n                if (data.attrValue === \"_blank\") {\r\n                    node.setAttribute(\"rel\", \"noreferrer noopener\");\r\n                } else {\r\n                    data.keepAttr = false;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    DOMPurify.setConfig(purifyConfig);\r\n}\r\n","\r\nclass LoginError extends Error {\r\n    constructor(type) {\r\n        super(type);\r\n        this.name = \"LoginError\";\r\n    }\r\n}\r\n\r\nclass ServerOutageError extends Error {\r\n    constructor(msg) {\r\n        super(msg);\r\n        this.name = \"ServerOutageError\";\r\n    }\r\n}\r\n\r\nclass HTTPError extends Error {\r\n    constructor(code, message) {\r\n        super(message);\r\n        this.code = code;\r\n    }\r\n}\r\n\r\n\r\nclass FeatureDependencyError extends Error {\r\n    constructor(msg, featureName) {\r\n        super(msg);\r\n        this.featureName = featureName;\r\n    }\r\n}\r\n\r\nconst Errors = {\r\n    \"LoginError\": LoginError,\r\n    \"ServerOutageError\": ServerOutageError,\r\n    \"HTTPError\": HTTPError,\r\n    \"FeatureDependencyError\": FeatureDependencyError\r\n};\r\n\r\nexport {Errors};\r\n","\r\nclass HTML {\r\n\r\n    static escape(str) {\r\n\r\n        // @see https://stackoverflow.com/a/4835406\r\n        const map = {\r\n            \"&\": \"&amp;\",\r\n            \"<\": \"&lt;\",\r\n            \">\": \"&gt;\",\r\n            '\"': \"&quot;\",\r\n            \"'\": \"&#039;\"\r\n        };\r\n\r\n        return str.replace(/[&<>\"']/g, (m) => { return map[m]; });\r\n    }\r\n\r\n    static fragment(html) {\r\n        const template = document.createElement(\"template\");\r\n        template.innerHTML = DOMPurify.sanitize(html);\r\n        return template.content;\r\n    }\r\n\r\n    static element(html) {\r\n        return HTML.fragment(html).firstElementChild;\r\n    }\r\n\r\n    static _getNode(node) {\r\n        let _node = node;\r\n\r\n        if (typeof _node == \"undefined\" || _node === null) {\r\n            console.warn(`${_node} is not an Element.`);\r\n            return null;\r\n        }\r\n        if (typeof _node == \"string\") {\r\n            _node = document.querySelector(_node);\r\n        }\r\n        if (!(_node instanceof Element)) {\r\n            console.warn(`${_node} is not an Element.`);\r\n            return null;\r\n        }\r\n\r\n        return _node;\r\n    }\r\n\r\n    static inner(node, html) {\r\n        const _node = HTML._getNode(node);\r\n\r\n        if (_node) {\r\n            _node.innerHTML = DOMPurify.sanitize(html);\r\n        }\r\n        return _node;\r\n    }\r\n\r\n    static replace(node, html) {\r\n        const _node = HTML._getNode(node);\r\n\r\n        if (_node) {\r\n            _node.outerHTML = DOMPurify.sanitize(html);\r\n        }\r\n        return _node;\r\n    }\r\n\r\n    static wrap(node, html) {\r\n        const _node = HTML._getNode(node);\r\n\r\n        if (_node) {\r\n            const wrapper = HTML.element(html);\r\n            _node.replaceWith(wrapper);\r\n            wrapper.append(_node);\r\n            return wrapper;\r\n        } else {\r\n            return _node;\r\n        }\r\n    }\r\n\r\n    static adjacent(node, position, html) {\r\n        const _node = HTML._getNode(node);\r\n\r\n        if (_node) {\r\n            _node.insertAdjacentHTML(position, DOMPurify.sanitize(html));\r\n        }\r\n        return _node;\r\n    }\r\n\r\n    static beforeBegin(node, html) {\r\n        HTML.adjacent(node, \"beforebegin\", html);\r\n    }\r\n\r\n    static afterBegin(node, html) {\r\n        HTML.adjacent(node, \"afterbegin\", html);\r\n    }\r\n\r\n    static beforeEnd(node, html) {\r\n        HTML.adjacent(node, \"beforeend\", html);\r\n    }\r\n\r\n    static afterEnd(node, html) {\r\n        HTML.adjacent(node, \"afterend\", html);\r\n    }\r\n}\r\n\r\nexport {HTML};\r\n","import {HTML} from \"./Html\";\r\n\r\nclass HTMLParser {\r\n\r\n    static clearSpecialSymbols(string) {\r\n        return string.replace(/[\\u00AE\\u00A9\\u2122]/g, \"\");\r\n    }\r\n\r\n    static htmlToDOM(html) {\r\n        return HTML.fragment(html);\r\n    }\r\n\r\n    static htmlToElement(html) {\r\n        return HTML.element(html);\r\n    }\r\n\r\n    static getVariableFromText(text, name, type) {\r\n        let regex;\r\n        if (type === \"object\") {\r\n            regex = new RegExp(`${name}\\\\s*=\\\\s*(\\\\{.+?\\\\});`);\r\n        } else if (type === \"array\") {\r\n            regex = new RegExp(`${name}\\\\s*=\\\\s*(\\\\[.+?\\\\]);`);\r\n        } else if (type === \"int\") {\r\n            regex = new RegExp(`${name}\\\\s*=\\\\s*(.+?);`);\r\n        } else if (type === \"string\") {\r\n            regex = new RegExp(`${name}\\\\s*=\\\\s*(\\\\\".+?\\\\\");`);\r\n        } else {\r\n            return null;\r\n        }\r\n\r\n        const m = text.match(regex);\r\n        if (m) {\r\n            if (type === \"int\") {\r\n                return parseInt(m[1]);\r\n            }\r\n            return JSON.parse(m[1]);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    static getVariableFromDom(name, type, dom = document) {\r\n        for (const node of dom.querySelectorAll(\"script\")) {\r\n            const value = HTMLParser.getVariableFromText(node.textContent, name, type);\r\n\r\n            if (value !== null) {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nexport {HTMLParser};\r\n","\r\nclass CookieStorage {\r\n\r\n    static get(name, defaultValue) {\r\n        const _name = name.trim();\r\n\r\n        if (!CookieStorage.cache.has(_name)) {\r\n            return defaultValue;\r\n        }\r\n        return CookieStorage.cache.get(_name);\r\n    }\r\n\r\n    static set(name, val, ttl = 60 * 60 * 24 * 365) {\r\n        let _name = name.trim();\r\n        let _val = val.trim();\r\n\r\n        CookieStorage.cache.set(_name, _val);\r\n\r\n        _name = encodeURIComponent(_name);\r\n        _val = encodeURIComponent(_val);\r\n        document.cookie = `${_name}=${_val}; max-age=${ttl}`;\r\n    }\r\n\r\n    static remove(name) {\r\n        let _name = name.trim();\r\n        CookieStorage.cache.delete(_name);\r\n        _name = encodeURIComponent(_name);\r\n        document.cookie = `${_name}; expires=Thu, 01 Jan 1970 00:00:00 GMT`;\r\n    }\r\n\r\n    static init() {\r\n        CookieStorage.cache = new Map();\r\n        for (let [key, val] of document.cookie.split(\";\").map(kv => kv.split(\"=\"))) {\r\n            key = key.trim();\r\n            CookieStorage.cache.set(key, decodeURIComponent(val));\r\n        }\r\n    }\r\n}\r\n\r\nCookieStorage.init();\r\n\r\nexport {CookieStorage};\r\n","\r\nconst ContextType = Object.freeze({\r\n    \"BACKGROUND\": 1,\r\n    \"CONTENT_SCRIPT\": 2,\r\n    \"OPTIONS\": 3,\r\n});\r\n\r\nlet currentContext;\r\nif (browser.extension.getBackgroundPage) {\r\n    const bgPage = browser.extension.getBackgroundPage();\r\n\r\n    currentContext = (bgPage === window)\r\n        ? ContextType.BACKGROUND\r\n        : ContextType.OPTIONS;\r\n} else {\r\n    currentContext = ContextType.CONTENT_SCRIPT;\r\n}\r\n\r\nclass Environment {\r\n\r\n    static isBackgroundScript() {\r\n        return currentContext === ContextType.BACKGROUND;\r\n    }\r\n\r\n    static isContentScript() {\r\n        return currentContext === ContextType.CONTENT_SCRIPT;\r\n    }\r\n\r\n    static isOptions() {\r\n        return currentContext === ContextType.OPTIONS;\r\n    }\r\n}\r\n\r\nexport {Environment};\r\n","import {CookieStorage} from \"../Storage/CookieStorage\";\r\nimport {Environment} from \"../Environment\";\r\n\r\nclass Language {\r\n\r\n    static getCurrentSteamLanguage() {\r\n        if (this._currentSteamLanguage !== null) {\r\n            return this._currentSteamLanguage;\r\n        }\r\n\r\n        for (const script of document.querySelectorAll(\"script[src]\")) {\r\n            const language = new URL(script.src).searchParams.get(\"l\");\r\n            if (language) {\r\n                Language._currentSteamLanguage = language;\r\n                return this._currentSteamLanguage;\r\n            }\r\n        }\r\n\r\n        // In a Content Context, we can check for a cookie\r\n        if (Environment.isContentScript()) {\r\n            Language._currentSteamLanguage = CookieStorage.get(\"Steam_Language\") || null;\r\n        }\r\n\r\n        return this._currentSteamLanguage;\r\n    }\r\n\r\n    static getLanguageCode(language) {\r\n        const code = Language.languages[language];\r\n        return code || \"en\";\r\n    }\r\n\r\n    static isCurrentLanguageOneOf(array) {\r\n        return array.includes(Language.getCurrentSteamLanguage());\r\n    }\r\n}\r\n\r\nLanguage._currentSteamLanguage = null;\r\nLanguage.languages = {\r\n    \"english\": \"en\",\r\n    \"bulgarian\": \"bg\",\r\n    \"czech\": \"cs\",\r\n    \"danish\": \"da\",\r\n    \"dutch\": \"nl\",\r\n    \"finnish\": \"fi\",\r\n    \"french\": \"fr\",\r\n    \"greek\": \"el\",\r\n    \"german\": \"de\",\r\n    \"hungarian\": \"hu\",\r\n    \"italian\": \"it\",\r\n    \"japanese\": \"ja\",\r\n    \"koreana\": \"ko\",\r\n    \"norwegian\": \"no\",\r\n    \"polish\": \"pl\",\r\n    \"portuguese\": \"pt-PT\",\r\n    \"brazilian\": \"pt-BR\",\r\n    \"russian\": \"ru\",\r\n    \"romanian\": \"ro\",\r\n    \"schinese\": \"zh-CN\",\r\n    \"spanish\": \"es-ES\",\r\n    \"latam\": \"es-419\",\r\n    \"swedish\": \"sv-SE\",\r\n    \"tchinese\": \"zh-TW\",\r\n    \"thai\": \"th\",\r\n    \"turkish\": \"tr\",\r\n    \"ukrainian\": \"ua\",\r\n    \"vietnamese\": \"vi\",\r\n};\r\n\r\nexport {Language};\r\n","\r\nclass ExtensionResources {\r\n\r\n    static getURL(pathname) {\r\n        return browser.runtime.getURL(pathname);\r\n    }\r\n\r\n    static get(pathname) {\r\n        return fetch(ExtensionResources.getURL(pathname));\r\n    }\r\n\r\n    static getJSON(pathname) {\r\n        return ExtensionResources.get(pathname).then(r => r.json());\r\n    }\r\n\r\n    static getText(pathname) {\r\n        return ExtensionResources.get(pathname).then(r => r.text());\r\n    }\r\n}\r\n\r\nexport {ExtensionResources};\r\n","import {BackgroundSimple} from \"../BackgroundSimple\";\r\nimport {ExtensionResources} from \"../ExtensionResources\";\r\nimport {Language} from \"./Language\";\r\nimport {SyncedStorage} from \"../Storage/SyncedStorage\";\r\n\r\n\r\nclass Localization {\r\n\r\n    static loadLocalization(code) {\r\n        return ExtensionResources.getJSON(`/localization/${code}.json`);\r\n    }\r\n\r\n    static init() {\r\n        if (Localization._promise) { return Localization._promise; }\r\n\r\n        let currentSteamLanguage = Language.getCurrentSteamLanguage();\r\n        const storedSteamLanguage = SyncedStorage.get(\"language\");\r\n        if (currentSteamLanguage === null) {\r\n            currentSteamLanguage = storedSteamLanguage;\r\n        } else if (currentSteamLanguage !== storedSteamLanguage) {\r\n            SyncedStorage.set(\"language\", currentSteamLanguage);\r\n            BackgroundSimple.action(\"clearpurchases\");\r\n        }\r\n\r\n        function deepAssign(target, source) {\r\n\r\n            // Object.assign() but deep-assigning objects recursively\r\n            for (const [key, val] of Object.entries(source)) {\r\n                if (typeof target[key] === \"undefined\") {\r\n                    console.warn(\"The key %s doesn't exist in the English localization file\", key);\r\n                    continue;\r\n                }\r\n                if (typeof val === \"object\") {\r\n                    deepAssign(target[key], val);\r\n                } else if (val !== \"\") {\r\n                    target[key] = val;\r\n                }\r\n            }\r\n            return target;\r\n        }\r\n\r\n        const local = Language.getLanguageCode(currentSteamLanguage);\r\n        const codes = [\"en\"];\r\n        if (local !== null && local !== \"en\") {\r\n            codes.push(local);\r\n        }\r\n        Localization._promise = Promise.all(\r\n            codes.map(lc => Localization.loadLocalization(lc))\r\n        ).then(([english, local]) => {\r\n            Localization.str = english;\r\n            if (local) {\r\n                deepAssign(Localization.str, local);\r\n            }\r\n            return Localization.str;\r\n        });\r\n        return Localization._promise;\r\n    }\r\n\r\n    static then(onDone, onCatch) {\r\n        return Localization.init().then(onDone, onCatch);\r\n    }\r\n\r\n    static getString(key) {\r\n\r\n        // Source: http://stackoverflow.com/a/24221895\r\n        const path = key.split(\".\").reverse();\r\n        let current = Localization.str;\r\n\r\n        while (path.length) {\r\n            if (typeof current !== \"object\") {\r\n                return null;\r\n            }\r\n            current = current[path.pop()];\r\n        }\r\n        return current;\r\n    }\r\n}\r\n\r\nLocalization._promise = null;\r\n\r\n\r\nexport {Localization};\r\n","\r\nclass BackgroundSimple {\r\n    static message(message) {\r\n        return browser.runtime.sendMessage(message);\r\n    }\r\n\r\n    static action(requested, ...params) {\r\n        if (!params.length) { return this.message({\"action\": requested}); }\r\n        return this.message({\"action\": requested, \"params\": params});\r\n    }\r\n}\r\n\r\nexport {BackgroundSimple};\r\n","import {SyncedStorage} from \"./Storage/SyncedStorage\";\r\n\r\nconst PermissionOptions = Object.freeze({\r\n    \"context_steam_store\": {\r\n        \"persistent\": true,\r\n        \"permissions\": [\"contextMenus\"]\r\n    },\r\n    \"context_steam_market\": {\r\n        \"persistent\": true,\r\n        \"permissions\": [\"contextMenus\"]\r\n    },\r\n    \"context_itad\": {\r\n        \"persistent\": true,\r\n        \"permissions\": [\"contextMenus\"]\r\n    },\r\n    \"context_bartervg\": {\r\n        \"persistent\": true,\r\n        \"permissions\": [\"contextMenus\"]\r\n    },\r\n    \"context_steamdb\": {\r\n        \"persistent\": true,\r\n        \"permissions\": [\"contextMenus\"]\r\n    },\r\n    \"context_steamdb_instant\": {\r\n        \"persistent\": true,\r\n        \"permissions\": [\"contextMenus\"]\r\n    },\r\n    \"context_steam_keys\": {\r\n        \"persistent\": true,\r\n        \"permissions\": [\"contextMenus\"]\r\n    },\r\n});\r\n\r\nclass Permissions {\r\n\r\n    /**\r\n     * @return Promise\r\n     */\r\n    static contains(permissionList) {\r\n        return browser.permissions.contains({\"permissions\": permissionList});\r\n    }\r\n\r\n    /**\r\n     * @return Promise\r\n     */\r\n    static async request(permissionList) {\r\n        // Prevents requesting permissions that are not optional (contextMenus for Firefox)\r\n        if (await this.contains(permissionList)) { return true; }\r\n\r\n        return browser.permissions.request({\"permissions\": permissionList});\r\n    }\r\n\r\n    /**\r\n     * @return Promise\r\n     */\r\n    static remove(permissionList) {\r\n        if (permissionList.includes(\"contextMenus\")) {\r\n            browser.contextMenus.removeAll();\r\n        }\r\n        return browser.permissions.remove({\"permissions\": permissionList});\r\n    }\r\n\r\n    static async when(permission, onAdded, onRemoved) {\r\n        if (onAdded) {\r\n            if (await Permissions.contains([permission])) {\r\n                onAdded();\r\n            }\r\n\r\n            browser.permissions.onAdded.addListener(p => {\r\n                if (p.permissions.includes(permission)) {\r\n                    onAdded();\r\n                }\r\n            });\r\n        }\r\n\r\n        if (onRemoved) {\r\n            browser.permissions.onRemoved.addListener(p => {\r\n                if (p.permissions.includes(permission)) {\r\n                    onRemoved();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    static requestOption(option) {\r\n        return Permissions.request(PermissionOptions[option].permissions);\r\n    }\r\n\r\n    static removeOption(optionToRemove) {\r\n\r\n        // If any of the permissions is in use by another option, don't remove.\r\n        const unusedPermissions = Permissions._getUnusedPermissions(optionToRemove);\r\n        if (unusedPermissions.length === 0) {\r\n            return Promise.resolve(true);\r\n        }\r\n\r\n        return Permissions.remove(unusedPermissions);\r\n    }\r\n\r\n    static _getUnusedPermissions(option) {\r\n        const used = new Set();\r\n        for (const [key, setup] of Object.entries(PermissionOptions)) {\r\n            if (option === key || (setup.persistent && !SyncedStorage.get(key))) {\r\n                continue;\r\n            }\r\n\r\n            for (const p of setup.permissions) {\r\n                used.add(p);\r\n            }\r\n        }\r\n\r\n        const unused = new Set();\r\n        for (const p of PermissionOptions[option].permissions) {\r\n            if (!used.has(p)) {\r\n                unused.add(p);\r\n            }\r\n        }\r\n\r\n        return Array.from(unused.values());\r\n    }\r\n}\r\n\r\nexport {PermissionOptions, Permissions};\r\n","import {Localization} from \"../../Core/Localization/Localization\";\r\nimport {SyncedStorage} from \"../../Core/Storage/SyncedStorage\";\r\nimport {Permissions} from \"../../modulesCore\";\r\n\r\nclass ContextMenu {\r\n\r\n    static onClick(info) {\r\n        const query = encodeURIComponent(info.selectionText.trim());\r\n        const url = ContextMenu.queryLinks[info.menuItemId];\r\n        if (!url) { return; }\r\n\r\n        if (info.menuItemId === \"context_steam_keys\") {\r\n            const steamKeys = query.match(/[A-Z0-9]{5}(-[A-Z0-9]{5}){2}/g);\r\n            if (!steamKeys || steamKeys.length === 0) {\r\n\r\n                // eslint-disable-next-line no-alert -- TODO Find a better way\r\n                window.alert(Localization.str.options.no_keys_found);\r\n                return;\r\n            }\r\n\r\n            for (const steamKey of steamKeys) {\r\n                browser.tabs.create({\"url\": url.replace(\"__steamkey__\", steamKey)});\r\n            }\r\n        } else {\r\n            browser.tabs.create({\"url\": url.replace(\"__query__\", query)});\r\n        }\r\n    }\r\n\r\n    static async build() {\r\n        await Localization;\r\n        await SyncedStorage;\r\n\r\n        for (const option of Object.keys(ContextMenu.queryLinks)) {\r\n            if (!SyncedStorage.get(option)) { continue; }\r\n\r\n            browser.contextMenus.create({\r\n                \"id\": option,\r\n                \"title\": Localization.str.options[option].replace(\"__query__\", \"%s\"),\r\n                \"contexts\": [\"selection\"]\r\n            },\r\n\r\n            /*\r\n             * TODO don't recreate the context menu entries on each change, only update\r\n             * the affected entry (which should also prevent this error)\r\n             * Error when you create an entry with duplicate id\r\n             */\r\n            () => chrome.runtime.lastError);\r\n        }\r\n    }\r\n\r\n    static async update() {\r\n        if (!await Permissions.contains([\"contextMenus\"])) { return null; }\r\n\r\n        await browser.contextMenus.removeAll();\r\n        return ContextMenu.build();\r\n    }\r\n}\r\n\r\nContextMenu.queryLinks = {\r\n    \"context_steam_store\": \"https://store.steampowered.com/search/?term=__query__\",\r\n    \"context_steam_market\": \"https://steamcommunity.com/market/search?q=__query__\",\r\n    \"context_itad\": \"https://isthereanydeal.com/search/?q=__query__\",\r\n    \"context_bartervg\": \"https://barter.vg/search?q=__query__\",\r\n    \"context_steamdb\": \"https://steamdb.info/search/?q=__query__\",\r\n    \"context_steamdb_instant\": \"https://steamdb.info/instantsearch/?query=__query__\",\r\n    \"context_steam_keys\": \"https://store.steampowered.com/account/registerkey?key=__steamkey__\"\r\n};\r\n\r\nexport {ContextMenu};\r\n","class Timer {\r\n\r\n    constructor(duration) {\r\n        this._promise = new Promise(resolve => {\r\n            this._id = setTimeout(() => { resolve(); }, duration);\r\n        });\r\n    }\r\n\r\n    then(onSuccess, onFail) {\r\n        if (this._promise) {\r\n            return this._promise.then(onSuccess, onFail);\r\n        }\r\n\r\n        throw new Error(\"Timer has been cleared before\");\r\n    }\r\n\r\n    clear() {\r\n        clearTimeout(this._id);\r\n        this._promise = null;\r\n    }\r\n}\r\n\r\nclass ResettableTimer {\r\n\r\n    constructor(onDone, duration) {\r\n        this.onDone = onDone;\r\n        this.duration = duration;\r\n\r\n        this.reset();\r\n    }\r\n\r\n    get running() { return this._running; }\r\n\r\n    reset() {\r\n        if (typeof this._id !== \"undefined\") {\r\n            clearTimeout(this._id);\r\n        }\r\n\r\n        this._id = setTimeout(async() => {\r\n            await this.onDone();\r\n            this._running = false;\r\n        }, this.duration);\r\n\r\n        this._running = true;\r\n    }\r\n}\r\n\r\nclass TimeUtils {\r\n\r\n    static timer(duration) {\r\n        return new Timer(duration);\r\n    }\r\n\r\n    static resettableTimer(onDone, duration) {\r\n        return new ResettableTimer(onDone, duration);\r\n    }\r\n\r\n    static now() {\r\n        return Math.trunc(Date.now() / 1000);\r\n    }\r\n}\r\n\r\nexport {TimeUtils};\r\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        const returnVal = await target[targetFuncName](...args);\n        if (isWrite)\n            await tx.done;\n        return returnVal;\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import {Info} from \"../../Core/Info\";\r\nimport {TimeUtils} from \"../../Core/Utils/TimeUtils\";\r\nimport {openDB} from \"idb\";\r\n\r\nclass IndexedDB {\r\n\r\n    static init() {\r\n        if (IndexedDB._promise) { return IndexedDB._promise; }\r\n        IndexedDB._promise = openDB(\"Augmented Steam\", Info.db_version, {\r\n            upgrade(db, oldVersion, newVersion, tx) {\r\n                if (oldVersion < 1) {\r\n                    db.createObjectStore(\"coupons\").createIndex(\"appid\", \"appids\", {\"unique\": false, \"multiEntry\": true});\r\n                    db.createObjectStore(\"giftsAndPasses\").createIndex(\"appid\", \"\", {\"unique\": false, \"multiEntry\": true});\r\n                    db.createObjectStore(\"items\");\r\n                    db.createObjectStore(\"earlyAccessAppids\");\r\n                    db.createObjectStore(\"purchases\");\r\n                    db.createObjectStore(\"dynamicStore\").createIndex(\"appid\", \"\", {\"unique\": false, \"multiEntry\": true});\r\n                    db.createObjectStore(\"packages\").createIndex(\"expiry\", \"expiry\");\r\n                    db.createObjectStore(\"storePageData\").createIndex(\"expiry\", \"expiry\");\r\n                    db.createObjectStore(\"profiles\").createIndex(\"expiry\", \"expiry\");\r\n                    db.createObjectStore(\"rates\");\r\n                    db.createObjectStore(\"notes\");\r\n                    db.createObjectStore(\"collection\");\r\n                    db.createObjectStore(\"waitlist\");\r\n                    db.createObjectStore(\"itadImport\");\r\n                }\r\n\r\n                if (oldVersion < 2) {\r\n                    db.createObjectStore(\"workshopFileSizes\").createIndex(\"expiry\", \"expiry\");\r\n                    db.createObjectStore(\"reviews\").createIndex(\"expiry\", \"expiry\");\r\n                }\r\n\r\n                if (oldVersion < 3) {\r\n                    db.createObjectStore(\"expiries\").createIndex(\"expiry\", \"\");\r\n\r\n                    tx.objectStore(\"packages\").deleteIndex(\"expiry\");\r\n                    tx.objectStore(\"storePageData\").deleteIndex(\"expiry\");\r\n                    tx.objectStore(\"profiles\").deleteIndex(\"expiry\");\r\n                    tx.objectStore(\"workshopFileSizes\").deleteIndex(\"expiry\");\r\n                    tx.objectStore(\"reviews\").deleteIndex(\"expiry\");\r\n                }\r\n            },\r\n            blocked() {\r\n                console.error(\"Failed to upgrade database, there is already an open connection\");\r\n            },\r\n        })\r\n            .then(db => { IndexedDB.db = db; })\r\n            .then(IndexedDB._deleteOldData);\r\n\r\n        return IndexedDB._promise;\r\n    }\r\n\r\n    static then(onDone, onCatch) {\r\n        return IndexedDB.init().then(onDone, onCatch);\r\n    }\r\n\r\n    static async _deleteOldData() {\r\n        const expiryStore = IndexedDB.db.transaction(\"expiries\", \"readwrite\").store;\r\n        let cursor = await expiryStore.index(\"expiry\").openCursor(IDBKeyRange.upperBound(TimeUtils.now()));\r\n        const expired = [];\r\n        const stores = {};\r\n        const promises = [];\r\n\r\n        while (cursor) {\r\n            expired.push(cursor.primaryKey);\r\n            promises.push(expiryStore.delete(cursor.primaryKey));\r\n            cursor = await cursor.continue();\r\n        }\r\n\r\n        for (const expiryKey of expired) {\r\n            const [storeName, key] = expiryKey.split(/_/);\r\n            if (!stores[storeName]) {\r\n                stores[storeName] = [];\r\n            }\r\n\r\n            if (key) {\r\n                stores[storeName].push(key);\r\n            }\r\n        }\r\n\r\n        for (const [storeName, keys] of Object.entries(stores)) {\r\n\r\n            const dataStore = IndexedDB.db.transaction(storeName, \"readwrite\").store;\r\n\r\n            if (IndexedDB.timestampedStores.has(storeName)) {\r\n                promises.push(dataStore.clear());\r\n            } else {\r\n                promises.push(Promise.all(keys.map(key => {\r\n\r\n                    const strKeyPromise = dataStore.delete(key);\r\n\r\n                    const nmbKey = Number(key);\r\n                    if (nmbKey) {\r\n                        return Promise.all([\r\n                            strKeyPromise,\r\n                            dataStore.delete(nmbKey),\r\n                        ]);\r\n                    }\r\n\r\n                    return strKeyPromise;\r\n                })));\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises);\r\n    }\r\n\r\n    static async put(storeName, data, {ttl, multiple = typeof data === \"object\"} = {}) {\r\n        const tx = IndexedDB.db.transaction(storeName, \"readwrite\");\r\n\r\n        let expiry;\r\n        const expiryKeys = [];\r\n\r\n        const cached = IndexedDB.cacheObjectStores.has(storeName);\r\n        const timestampedEntry = IndexedDB.timestampedEntriesStores.has(storeName);\r\n\r\n        function nonAssociativeData(data) {\r\n            let promise;\r\n            if (tx.store.autoIncrement || tx.store.keyPath !== null) {\r\n                promise = tx.store.put(data);\r\n            } else {\r\n                promise = tx.store.put(null, data);\r\n            }\r\n            promise.then(key => {\r\n                if (timestampedEntry) { expiryKeys.push(`${storeName}_${key}`); }\r\n            });\r\n        }\r\n\r\n        if (cached) {\r\n            const _ttl = ttl || IndexedDB.cacheObjectStores.get(storeName);\r\n            expiry = TimeUtils.now() + _ttl;\r\n\r\n            if (!timestampedEntry) {\r\n                expiryKeys.push(storeName);\r\n            }\r\n        }\r\n\r\n        if (multiple) {\r\n            if (Array.isArray(data)) {\r\n                data.forEach(nonAssociativeData);\r\n            } else if (typeof data === \"object\") {\r\n                const entries = data instanceof Map ? data.entries() : Object.entries(data);\r\n                for (const [key, value] of entries) {\r\n                    tx.store.put(value, key).then(key => {\r\n                        if (timestampedEntry) { expiryKeys.push(`${storeName}_${key}`); }\r\n                    });\r\n                }\r\n            } else {\r\n                console.warn(\"multiple parameter specified but the data is a primitive\");\r\n            }\r\n        } else {\r\n            nonAssociativeData(data);\r\n        }\r\n\r\n        await tx.done;\r\n\r\n        const expiryTx = IndexedDB.db.transaction(\"expiries\", \"readwrite\");\r\n\r\n        for (const key of expiryKeys) {\r\n            expiryTx.store.put(expiry, key);\r\n        }\r\n\r\n        return expiryTx.done;\r\n    }\r\n\r\n    static async get(storeName, key, options = {}) {\r\n        const keys = IndexedDB._asArray(key);\r\n\r\n        await Promise.all([\r\n            IndexedDB.checkStoreExpiry(storeName, options),\r\n            IndexedDB.checkEntryExpiry(storeName, keys, options),\r\n        ]);\r\n\r\n        const store = IndexedDB.db.transaction(storeName).store;\r\n        const values = await Promise.all(keys.map(key => store.get(key)));\r\n\r\n        return Array.isArray(key) ? IndexedDB._resultsAsObject(keys, values) : values[0];\r\n    }\r\n\r\n    static async getAll(storeName, options = {}) {\r\n        const keys = [];\r\n        const values = [];\r\n        let cursor;\r\n\r\n        await IndexedDB.checkStoreExpiry(storeName, options);\r\n\r\n        if (IndexedDB.timestampedEntriesStores.has(storeName)) {\r\n            await IndexedDB.checkEntryExpiry(storeName, await IndexedDB.db.getAllKeys(storeName), options);\r\n        }\r\n\r\n        cursor = await IndexedDB.db.transaction(storeName).store.openCursor();\r\n\r\n        while (cursor) {\r\n            keys.push(cursor.key);\r\n            values.push(cursor.value);\r\n\r\n            cursor = await cursor.continue();\r\n        }\r\n\r\n        return IndexedDB._resultsAsObject(keys, await Promise.all(values));\r\n    }\r\n\r\n    static async getFromIndex(storeName, indexName, key, options = {}) {\r\n\r\n        // It doesn't make sense to query on an index from a timestamped entry store, since the data is not complete\r\n        if (IndexedDB.timestampedEntriesStores.has(storeName)) { return null; }\r\n\r\n        await IndexedDB.checkStoreExpiry(storeName, options);\r\n\r\n        const keys = IndexedDB._asArray(key);\r\n        const index = IndexedDB.db.transaction(storeName).store.index(indexName);\r\n\r\n        const values = await Promise.all(keys.map(key => {\r\n            if (options.asKey) {\r\n                if (options.all) {\r\n                    return index.getAllKeys(key);\r\n                }\r\n                return index.getKey(key);\r\n            }\r\n\r\n            if (options.all) {\r\n                return index.getAll(key);\r\n            }\r\n\r\n            return index.get(key);\r\n        }));\r\n\r\n        return Array.isArray(key) ? IndexedDB._resultsAsObject(keys, values) : values[0];\r\n    }\r\n\r\n    static async indexContainsKey(storeName, indexName, key, options = {}) {\r\n\r\n        // It doesn't make sense to query on an index from a timestamped entry store, since the data is not complete\r\n        if (IndexedDB.timestampedEntriesStores.has(storeName)) { return null; }\r\n\r\n        await IndexedDB.checkStoreExpiry(storeName, options);\r\n\r\n        const keys = IndexedDB._asArray(key);\r\n        const index = IndexedDB.db.transaction(storeName).store.index(indexName);\r\n\r\n        const values = await Promise.all(keys.map(key => index.openKeyCursor(key)\r\n            .then(cursor => Boolean(cursor))));\r\n\r\n        return Array.isArray(key) ? IndexedDB._resultsAsObject(keys, values) : values[0];\r\n    }\r\n\r\n    static delete(storeName, key) {\r\n\r\n        const keys = IndexedDB._asArray(key);\r\n        const dataStore = IndexedDB.db.transaction(storeName, \"readwrite\").store;\r\n        let expiryStore;\r\n\r\n        if (IndexedDB.cacheObjectStores.has(storeName)) {\r\n            expiryStore = IndexedDB.db.transaction(\"expiries\", \"readwrite\").store;\r\n        }\r\n\r\n        return Promise.all(keys.map(key => {\r\n            const dataPromise = dataStore.delete(key);\r\n            if (expiryStore) {\r\n                return Promise.all([\r\n                    dataPromise,\r\n                    expiryStore.delete(IndexedDB.timestampedStores.has(storeName) ? storeName : `${storeName}_${key}`)\r\n                ]);\r\n            }\r\n            return dataPromise;\r\n        }));\r\n    }\r\n\r\n    static clear(storeName = Array.from(IndexedDB.cacheObjectStores.keys())) {\r\n        const storeNames = IndexedDB._asArray(storeName);\r\n        let expiryStore;\r\n\r\n        if (storeNames.some(storeName => IndexedDB.cacheObjectStores.has(storeName))) {\r\n            expiryStore = IndexedDB.db.transaction(\"expiries\", \"readwrite\").store;\r\n        }\r\n\r\n        return Promise.all(storeNames.map(storeName => {\r\n            const clearPromise = IndexedDB.db.clear(storeName);\r\n\r\n            if (IndexedDB.cacheObjectStores.has(storeName)) {\r\n\r\n                let expiryKey;\r\n                if (IndexedDB.timestampedStores.has(storeName)) {\r\n                    expiryKey = storeName;\r\n                } else {\r\n                    expiryKey = IDBKeyRange.bound(\r\n                        `${storeName}_`,\r\n                        `${storeName}${String.fromCharCode(\"_\".charCodeAt(0) + 1)}`,\r\n                        false,\r\n                        true\r\n                    );\r\n                }\r\n\r\n                return Promise.all([\r\n                    clearPromise,\r\n                    expiryStore.delete(expiryKey),\r\n                ]);\r\n            }\r\n\r\n            return clearPromise;\r\n        }));\r\n    }\r\n\r\n    static async contains(storeName, key, options = {}) {\r\n        const keys = IndexedDB._asArray(key);\r\n\r\n        await Promise.all([\r\n            IndexedDB.checkStoreExpiry(storeName, options),\r\n            IndexedDB.checkEntryExpiry(storeName, keys, options),\r\n        ]);\r\n\r\n        const store = IndexedDB.db.transaction(storeName).store;\r\n\r\n        const values = await Promise.all(keys.map(key => store.openCursor(key)\r\n            .then(cursor => Boolean(cursor))));\r\n\r\n        return Array.isArray(key) ? IndexedDB._resultsAsObject(keys, values) : values[0];\r\n    }\r\n\r\n    static async checkEntryExpiry(storeName, keys, options = {}) {\r\n\r\n        if (!IndexedDB.timestampedEntriesStores.has(storeName)) { return null; }\r\n\r\n        const tx = IndexedDB.db.transaction(\"expiries\");\r\n        const expired = [];\r\n\r\n        for (const key of keys) {\r\n            tx.store.get(`${storeName}_${key}`).then(expiry => {\r\n                if (!expiry || IndexedDB.isExpired(expiry)) {\r\n                    expired.push(key);\r\n                }\r\n            });\r\n        }\r\n\r\n        await tx.done;\r\n\r\n        if (options.preventFetch) {\r\n            const dataTx = IndexedDB.db.transaction(storeName, \"readwrite\");\r\n\r\n            for (const key of expired) {\r\n                dataTx.store.delete(key);\r\n            }\r\n\r\n            return dataTx.done;\r\n        }\r\n\r\n        return Promise.all(expired.map(key => IndexedDB.fetchUpdatedData(storeName, key, options.params)));\r\n    }\r\n\r\n    static async checkStoreExpiry(storeName, options = {}) {\r\n\r\n        if (!IndexedDB.timestampedStores.has(storeName)) { return null; }\r\n\r\n        const expiry = await IndexedDB.db.get(\"expiries\", storeName);\r\n        let expired = true;\r\n\r\n        if (expiry) {\r\n            expired = IndexedDB.isExpired(expiry);\r\n        }\r\n\r\n        if (expired) {\r\n            await IndexedDB.clear(storeName);\r\n            if (!options.preventFetch) {\r\n                return IndexedDB.fetchUpdatedData(storeName, null, options.params);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    static fetchUpdatedData(storeName, key, params) {\r\n\r\n        const requestKey = key ? `${storeName}_${key}` : storeName;\r\n        if (IndexedDB._ongoingRequests.has(requestKey)) {\r\n            return IndexedDB._ongoingRequests.get(requestKey);\r\n        }\r\n\r\n        let req;\r\n        const timestampedStore = IndexedDB.timestampedStores.has(storeName);\r\n        if (timestampedStore) {\r\n            req = IndexedDB.objStoreFetchFns.get(storeName)({params});\r\n        } else {\r\n            req = IndexedDB.objStoreFetchFns.get(storeName)({params, key});\r\n        }\r\n        req = req\r\n            .catch(async err => {\r\n                console.group(\"Object store data\");\r\n                if (key) {\r\n                    console.error(\"Failed to update key %s of object store %s\", key, storeName);\r\n                } else {\r\n                    console.error(\"Failed to update object store %s\", storeName);\r\n                }\r\n                console.error(err);\r\n                console.groupEnd();\r\n\r\n                // Wait some seconds before retrying\r\n                await IndexedDB.db.put(\"expiries\", TimeUtils.now() + 60, timestampedStore ? storeName : `${storeName}_${key}`);\r\n\r\n                throw err;\r\n            })\r\n            .finally(() => IndexedDB._ongoingRequests.delete(requestKey));\r\n        IndexedDB._ongoingRequests.set(requestKey, req);\r\n        return req;\r\n    }\r\n\r\n    static isExpired(expiry) {\r\n        return expiry <= TimeUtils.now();\r\n    }\r\n\r\n    static _asArray(key) {\r\n        return Array.isArray(key) ? key : [key];\r\n    }\r\n\r\n    static _resultsAsObject(keys, values) {\r\n        return keys.reduce((acc, key, i) => {\r\n            acc[key] = values[i];\r\n            return acc;\r\n        }, {});\r\n    }\r\n}\r\nIndexedDB._promise = null;\r\nIndexedDB._ongoingRequests = new Map();\r\n\r\n/*\r\n *  Object stores in this map won't get checked\r\n *  for timestamps if cached.\r\n *  Instead of checking the single entry, the object store itself has\r\n *  a entry named \"expiry\".\r\n *\r\n *  This allows us to reduce the overhead of having one timestamp for\r\n *  each individual entry, although they're basically fetched during\r\n *  the same time.\r\n */\r\nIndexedDB.timestampedStores = new Map([\r\n    [\"coupons\", 60 * 60],\r\n    [\"giftsAndPasses\", 60 * 60],\r\n    [\"items\", 60 * 60],\r\n    [\"earlyAccessAppids\", 60 * 60],\r\n    [\"purchases\", 24 * 60 * 60],\r\n    [\"dynamicStore\", 15 * 60],\r\n    [\"rates\", 60 * 60],\r\n    [\"collection\", 15 * 60],\r\n    [\"waitlist\", 15 * 60],\r\n]);\r\n\r\nIndexedDB.timestampedEntriesStores = new Map([\r\n    [\"packages\", 7 * 24 * 60 * 60],\r\n    [\"storePageData\", 60 * 60],\r\n    [\"profiles\", 24 * 60 * 60],\r\n    [\"workshopFileSizes\", 5 * 24 * 60 * 60],\r\n    [\"reviews\", 60 * 60],\r\n]);\r\n\r\nIndexedDB.cacheObjectStores = new Map([...IndexedDB.timestampedStores, ...IndexedDB.timestampedEntriesStores]);\r\n\r\nexport {IndexedDB};\r\n","\r\n// TODO use https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage\r\nclass LocalStorage {\r\n    static get(key, defaultValue) {\r\n        const item = localStorage.getItem(key);\r\n        if (!item) { return defaultValue; }\r\n        try {\r\n            return JSON.parse(item);\r\n        } catch (err) {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    static set(key, value) {\r\n        localStorage.setItem(key, JSON.stringify(value));\r\n    }\r\n\r\n    static has(key) {\r\n        return localStorage.getItem(key) !== null;\r\n    }\r\n\r\n    static remove(key) {\r\n        localStorage.removeItem(key);\r\n    }\r\n\r\n    static keys() {\r\n        const result = [];\r\n        for (let i = localStorage.length - 1; i >= 0; --i) {\r\n            result.push(localStorage.key(i));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static clear() {\r\n        localStorage.clear();\r\n    }\r\n}\r\n\r\nexport {LocalStorage};\r\n","\r\nclass GameId {\r\n\r\n    static parseId(id) {\r\n        if (!id) { return null; }\r\n\r\n        const intId = parseInt(id);\r\n        if (!intId) { return null; }\r\n\r\n        return intId;\r\n    }\r\n\r\n    static getAppid(text) {\r\n        let _text = text;\r\n\r\n        if (!_text) { return null; }\r\n\r\n        if (_text instanceof HTMLElement) {\r\n            const appid = _text.dataset.dsAppid;\r\n            if (appid) { return GameId.parseId(appid); }\r\n            _text = _text.href;\r\n            if (!_text) { return null; }\r\n        }\r\n\r\n        // app, market/listing\r\n        const m = _text.match(/(?:store\\.steampowered|steamcommunity)\\.com\\/(?:app|market\\/listings)\\/(\\d+)\\/?/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static getSubid(text) {\r\n        let _text = text;\r\n\r\n        if (!_text) { return null; }\r\n\r\n        if (_text instanceof HTMLElement) {\r\n            const subid = _text.dataset.dsPackageid;\r\n            if (subid) { return GameId.parseId(subid); }\r\n            _text = _text.href;\r\n            if (!_text) { return null; }\r\n        }\r\n\r\n        const m = _text.match(/(?:store\\.steampowered|steamcommunity)\\.com\\/sub\\/(\\d+)\\/?/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static getBundleid(text) {\r\n        let _text = text;\r\n\r\n        if (!_text) { return null; }\r\n\r\n        if (_text instanceof HTMLElement) {\r\n            const bundleid = _text.dataset.dsBundleid;\r\n            if (bundleid) { return GameId.parseId(bundleid); }\r\n            _text = _text.href;\r\n            if (!_text) { return null; }\r\n        }\r\n\r\n        const m = _text.match(/(?:store\\.steampowered|steamcommunity)\\.com\\/bundle\\/(\\d+)\\/?/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static trimStoreId(storeId) {\r\n        return Number(storeId.slice(storeId.indexOf(\"/\") + 1));\r\n    }\r\n\r\n    static getAppidImgSrc(text) {\r\n        if (!text) { return null; }\r\n        const m = text.match(/(?:cdn\\.akamai\\.steamstatic\\.com\\/steam|steamcdn-a\\.akamaihd\\.net\\/steam|steamcommunity\\/public\\/images)\\/apps\\/(\\d+)\\//);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static getAppidUriQuery(text) {\r\n        if (!text) { return null; }\r\n        const m = text.match(/appid=(\\d+)/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static getAppids(text) {\r\n        const regex = /(?:store\\.steampowered|steamcommunity)\\.com\\/app\\/(\\d+)\\/?/g;\r\n        const res = [];\r\n        let m;\r\n        while ((m = regex.exec(text)) !== null) {\r\n            const id = GameId.parseId(m[1]);\r\n            if (id) {\r\n                res.push(id);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    static getAppidFromId(text) {\r\n        if (!text) { return null; }\r\n        const m = text.match(/game_(\\d+)/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static getAppidFromGameCard(text) {\r\n        if (!text) { return null; }\r\n        const m = text.match(/\\/gamecards\\/(\\d+)/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n}\r\n\r\nexport {GameId};\r\n","import {IndexedDB} from \"./IndexedDB\";\r\n\r\nclass Api {\r\n\r\n    /*\r\n     * FF doesn't support static members\r\n     * static origin; // this *must* be overridden\r\n     * static params = {};\r\n     * withResponse? use a boolean to include Response object in result?\r\n     */\r\n    static _fetchWithDefaults(endpoint, query = {}, params = {}) {\r\n        const url = new URL(endpoint, this.origin);\r\n        const _params = {...this.params, ...params};\r\n        if (_params && _params.method === \"POST\" && !_params.body) {\r\n            const formData = new FormData();\r\n            for (const [k, v] of Object.entries(query)) {\r\n                formData.append(k, v);\r\n            }\r\n            _params.body = formData;\r\n        } else {\r\n            for (const [k, v] of Object.entries(query)) {\r\n                url.searchParams.append(k, v);\r\n            }\r\n        }\r\n        return fetch(url, _params);\r\n    }\r\n\r\n    static async getEndpoint(endpoint, query, responseHandler, params = {}) {\r\n        let _endpoint = endpoint;\r\n        if (!endpoint.endsWith(\"/\")) { _endpoint += \"/\"; }\r\n\r\n        const response = await this._fetchWithDefaults(_endpoint, query, Object.assign(params, {\"method\": \"GET\"}));\r\n        if (responseHandler) { responseHandler(response); }\r\n        return response.json();\r\n    }\r\n\r\n    static async getPage(endpoint, query, responseHandler, params = {}) {\r\n        const response = await this._fetchWithDefaults(endpoint, query, Object.assign(params, {\"method\": \"GET\"}));\r\n        if (responseHandler) { responseHandler(response); }\r\n        return response.text();\r\n    }\r\n\r\n    static async postEndpoint(endpoint, query, responseHandler, params = {}) {\r\n        let _endpoint = endpoint;\r\n        if (!endpoint.endsWith(\"/\")) { _endpoint += \"/\"; }\r\n\r\n        const response = await this._fetchWithDefaults(_endpoint, query, Object.assign(params, {\"method\": \"POST\"}));\r\n        if (responseHandler) { responseHandler(response); }\r\n        return response.json();\r\n    }\r\n\r\n    static async deleteEndpoint(endpoint, query, responseHandler, params = {}) {\r\n        let _endpoint = endpoint;\r\n        if (!endpoint.endsWith(\"/\")) { _endpoint += \"/\"; }\r\n\r\n        const response = await this._fetchWithDefaults(_endpoint, query, Object.assign(params, {\"method\": \"DELETE\"}));\r\n        if (responseHandler) { responseHandler(response); }\r\n        return response.json();\r\n    }\r\n\r\n    static endpointFactory(endpoint, objPath) {\r\n        return async params => {\r\n            let result = await this.getEndpoint(endpoint, params);\r\n            if (objPath) {\r\n                if (Array.isArray(objPath)) {\r\n                    for (const part of objPath) {\r\n                        result = result[part];\r\n                    }\r\n                } else {\r\n                    result = result[objPath];\r\n                }\r\n            } else {\r\n                result = result.data;\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n\r\n    static endpointFactoryCached(endpoint, storeName, mapFn) {\r\n        return async({params, key} = {}) => {\r\n            let result = await this.getEndpoint(endpoint, params);\r\n\r\n            if (mapFn) {\r\n                result = mapFn(result.data);\r\n            } else {\r\n                result = result.data;\r\n            }\r\n\r\n            return IndexedDB.put(storeName, typeof key === \"undefined\" ? result : new Map([[key, result]]));\r\n        };\r\n    }\r\n}\r\nApi.params = {};\r\n\r\nexport {Api};\r\n","import {TimeUtils} from \"../../Core/Utils/TimeUtils\";\r\nimport {LocalStorage} from \"../../Core/Storage/LocalStorage\";\r\n\r\nclass CacheStorage {\r\n\r\n    static isExpired(timestamp, ttl) {\r\n        let _ttl = ttl;\r\n        if (!timestamp) { return true; }\r\n        if (typeof ttl !== \"number\" || _ttl < 0) { _ttl = 0; }\r\n        return timestamp + _ttl <= TimeUtils.now();\r\n    }\r\n\r\n    static get(key, ttl, defaultValue) {\r\n        if (!ttl) { return defaultValue; }\r\n        let item = localStorage.getItem(`cache_${key}`);\r\n        if (!item) { return defaultValue; }\r\n        try {\r\n            item = JSON.parse(item);\r\n        } catch (err) {\r\n            return defaultValue;\r\n        }\r\n        if (!item.timestamp || CacheStorage.isExpired(item.timestamp, ttl)) { return defaultValue; }\r\n        return item.data;\r\n    }\r\n\r\n    static set(key, value) {\r\n        localStorage.setItem(`cache_${key}`, JSON.stringify({\"data\": value, \"timestamp\": TimeUtils.now()}));\r\n    }\r\n\r\n    static remove(key) {\r\n        localStorage.removeItem(`cache_${key}`);\r\n    }\r\n\r\n    static keys() {\r\n        return LocalStorage.keys()\r\n            .filter(k => k.startsWith(\"cache_\"))\r\n            .map(k => k.substring(6)); // \"cache_\".length == 6\r\n    }\r\n\r\n    static clear() {\r\n        const keys = CacheStorage.keys();\r\n        for (const key of keys) {\r\n            CacheStorage.remove(key);\r\n        }\r\n    }\r\n}\r\n\r\nexport {CacheStorage};\r\n","import {LocalStorage} from \"../../Core/Storage/LocalStorage\";\r\nimport {Errors} from \"../../Core/Errors/Errors\";\r\nimport {GameId} from \"../../Core/GameId\";\r\nimport {HTMLParser} from \"../../Core/Html/HtmlParser\";\r\nimport {Api} from \"./Api\";\r\nimport {CacheStorage} from \"./CacheStorage\";\r\nimport {IndexedDB} from \"./IndexedDB\";\r\n\r\nclass SteamCommunityApi extends Api {\r\n\r\n    /*\r\n     * static origin = \"https://steamcommunity.com/\";\r\n     * static params = { 'credentials': 'include', };\r\n     */\r\n\r\n    static cards(appid, border) {\r\n        return SteamCommunityApi.getPage(`/my/gamecards/${appid}`, (border ? {\"border\": 1} : {}));\r\n    }\r\n\r\n    static stats(path, appid) {\r\n        return SteamCommunityApi.getPage(`${path}/stats/${appid}`);\r\n    }\r\n\r\n    static async getInventory(contextId) {\r\n        const login = LocalStorage.get(\"login\");\r\n        if (!login) {\r\n            console.warn(\"Must be signed in to access Inventory\");\r\n            return null;\r\n        }\r\n\r\n        const params = {\"l\": \"english\", \"count\": 2000};\r\n        let data = null;\r\n        let result, lastAssetid;\r\n\r\n        do {\r\n            const thisParams = Object.assign(params, lastAssetid ? {\"start_assetid\": lastAssetid} : null);\r\n            result = await SteamCommunityApi.getEndpoint(`/inventory/${login.steamId}/753/${contextId}`, thisParams, res => {\r\n                if (res.status === 403) {\r\n                    throw new Errors.LoginError(\"community\");\r\n                }\r\n            });\r\n            if (result && result.success) {\r\n                if (!data) { data = {\"assets\": [], \"descriptions\": []}; }\r\n                if (result.assets) { data.assets = data.assets.concat(result.assets); }\r\n                if (result.descriptions) { data.descriptions = data.descriptions.concat(result.descriptions); }\r\n                lastAssetid = result.last_assetid;\r\n            }\r\n        } while (result.more_items);\r\n\r\n        if (!data) {\r\n            throw new Error(`Could not retrieve Inventory 753/${contextId}`);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /*\r\n     * Inventory functions, must be signed in to function correctly\r\n     */\r\n    static async coupons() { // context#3\r\n        const coupons = new Map();\r\n        const data = await SteamCommunityApi.getInventory(3);\r\n        if (!data) { return null; }\r\n\r\n        for (const description of data.descriptions) {\r\n            if (!description.type || description.type !== \"Coupon\") { continue; }\r\n            if (!description.actions) { continue; }\r\n\r\n            const coupon = {\r\n                \"image_url\": description.icon_url,\r\n                \"title\": description.name,\r\n                \"discount\": description.name.match(/([1-9][0-9])%/)[1],\r\n                \"id\": `${description.classid}_${description.instanceid}`\r\n            };\r\n            description.descriptions.forEach((desc, i) => {\r\n                const value = desc.value;\r\n                if (value.startsWith(\"Can't be applied with other discounts.\")) {\r\n                    Object.assign(coupon, {\r\n                        \"discount_note\": value,\r\n                        \"discount_note_id\": i,\r\n                        \"discount_doesnt_stack\": true,\r\n                    });\r\n                } else if (value.startsWith(\"(Valid\")) {\r\n                    Object.assign(coupon, {\r\n                        \"valid_id\": i,\r\n                        \"valid\": value,\r\n                    });\r\n                }\r\n            });\r\n\r\n            for (const action of description.actions) {\r\n                const match = action.link.match(/[1-9][0-9]*(?:,[1-9][0-9]*)*/);\r\n                if (!match) {\r\n                    console.warn(\"Couldn't find packageid(s) for link %s\", action.link);\r\n                    continue;\r\n                }\r\n\r\n                for (let packageid of match[0].split(\",\")) {\r\n                    packageid = Number(packageid);\r\n                    if (!coupons.has(packageid) || coupons.get(packageid).discount < coupon.discount) {\r\n                        coupons.set(packageid, coupon);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const packages = await IndexedDB.get(\"packages\", Array.from(coupons.keys()));\r\n\r\n        for (const [subid, coupon] of coupons.entries()) {\r\n            const details = packages[subid];\r\n            if (details) {\r\n                coupon.appids = details;\r\n            } else {\r\n                coupon.appids = [];\r\n            }\r\n        }\r\n\r\n        return IndexedDB.put(\"coupons\", coupons);\r\n    }\r\n\r\n    static getCoupon(appid) { return IndexedDB.getFromIndex(\"coupons\", \"appid\", appid); }\r\n    static hasCoupon(appid) { return IndexedDB.indexContainsKey(\"coupons\", \"appid\", appid); }\r\n\r\n    static async giftsAndPasses() { // context#1, gifts and guest passes\r\n        const gifts = [];\r\n        const passes = [];\r\n\r\n        let isPackage;\r\n\r\n        let data = await SteamCommunityApi.getInventory(1);\r\n        if (!data) { return null; }\r\n\r\n        function addGiftsAndPasses(description, desc) {\r\n            const appids = GameId.getAppids(desc.value);\r\n\r\n            // Gift package with multiple apps\r\n            isPackage = true;\r\n\r\n            for (const appid of appids) {\r\n                if (!appid) { continue; }\r\n                if (description.type === \"Gift\") {\r\n                    gifts.push(appid);\r\n                } else {\r\n                    passes.push(appid);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const description of data.descriptions) {\r\n            isPackage = false;\r\n            if (description.descriptions) {\r\n                for (const desc of description.descriptions) {\r\n                    if (desc.type !== \"html\") { continue; }\r\n\r\n                    addGiftsAndPasses(desc);\r\n\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Single app\r\n            if (!isPackage && description.actions) {\r\n                const appid = GameId.getAppid(description.actions[0].link);\r\n                if (appid) {\r\n                    if (description.type === \"Gift\") {\r\n                        gifts.push(appid);\r\n                    } else {\r\n                        passes.push(appid);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        data = {\r\n            \"gifts\": gifts,\r\n            \"passes\": passes,\r\n        };\r\n\r\n        return IndexedDB.put(\"giftsAndPasses\", data);\r\n    }\r\n\r\n    static hasGiftsAndPasses(appid) {\r\n        return IndexedDB.getFromIndex(\"giftsAndPasses\", \"appid\", appid, {\"all\": true, \"asKey\": true});\r\n    }\r\n\r\n    static async items() { // context#6, community items\r\n        // only used for market highlighting\r\n        const data = await SteamCommunityApi.getInventory(6);\r\n        if (data) {\r\n            return IndexedDB.put(\"items\", data.descriptions.map(item => item.market_hash_name));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static hasItem(hashes) { return IndexedDB.contains(\"items\", hashes); }\r\n\r\n    static async fetchWorkshopFileSize({\"key\": id}) {\r\n        const parser = new DOMParser();\r\n        const res = await SteamCommunityApi.getPage(\"/sharedfiles/filedetails/\", {id});\r\n        const doc = parser.parseFromString(res, \"text/html\");\r\n\r\n        const details = doc.querySelector(\".detailsStatRight\");\r\n        if (!details || !details.innerText.includes(\"MB\")) {\r\n            throw new Error(\"Couldn't find details block for workshop file size\");\r\n        }\r\n\r\n        const text = details.innerText.split(\" \")[0].trim();\r\n        const size = parseFloat(text.replace(/,/g, \"\"));\r\n\r\n        return IndexedDB.put(\"workshopFileSizes\", new Map([[Number(id), size * 1000]]));\r\n    }\r\n\r\n    static getWorkshopFileSize(id, preventFetch) {\r\n        return IndexedDB.get(\"workshopFileSizes\", Number(id), {preventFetch});\r\n    }\r\n\r\n    static _getReviewId(node) {\r\n        const input = node.querySelector(\"input\");\r\n\r\n        /*\r\n         * Only exists when the requested profile is yours\r\n         * (these are the input fields where you can change visibility and language of the review)\r\n         */\r\n        if (input) {\r\n            return Number(input.id.replace(\"ReviewVisibility\", \"\"));\r\n        }\r\n\r\n        // Otherwise you have buttons to vote for the review (Was it helpful or not, was it funny?)\r\n        return Number(node.querySelector(\".control_block > a\").id.replace(\"RecommendationVoteUpBtn\", \"\"));\r\n    }\r\n\r\n    static async fetchReviews({\"key\": steamId, \"params\": {reviewCount}}) {\r\n        const parser = new DOMParser();\r\n        const pageCount = 10;\r\n        const reviews = [];\r\n\r\n        for (let p = 1; p <= Math.ceil(reviewCount / pageCount); p++) {\r\n            const doc = parser.parseFromString(await SteamCommunityApi.getPage(`${steamId}/recommended`, {p}), \"text/html\");\r\n\r\n            for (const node of doc.querySelectorAll(\".review_box\")) {\r\n                const headerText = node.querySelector(\".header\").innerHTML.split(\"<br>\");\r\n                const playtimeText = node.querySelector(\".hours\").textContent.split(\"(\")[0].match(/(\\d+,)?\\d+\\.\\d+/);\r\n                const visibilityNode = node.querySelector(\".dselect_container:nth-child(2) .trigger\");\r\n\r\n                const id = SteamCommunityApi._getReviewId(node);\r\n                const rating = node.querySelector(\"[src*=thumbsUp]\") ? 1 : 0;\r\n                const helpful = headerText[0] && headerText[0].match(/\\d+/g) ? parseInt(headerText[0].match(/\\d+/g).join(\"\")) : 0;\r\n                const funny = headerText[1] && headerText[1].match(/\\d+/g) ? parseInt(headerText[1].match(/\\d+/g).join(\"\")) : 0;\r\n                const length = node.querySelector(\".content\").textContent.trim().length;\r\n                const visibility = visibilityNode ? visibilityNode.textContent : \"Public\";\r\n                const playtime = playtimeText ? parseFloat(playtimeText[0].split(\",\").join(\"\")) : 0.0;\r\n\r\n                reviews.push({\r\n                    rating,\r\n                    helpful,\r\n                    funny,\r\n                    length,\r\n                    visibility,\r\n                    playtime,\r\n                    \"node\": DOMPurify.sanitize(node.outerHTML),\r\n                    id\r\n                });\r\n            }\r\n        }\r\n\r\n        return IndexedDB.put(\"reviews\", {[steamId]: reviews});\r\n    }\r\n\r\n    static async updateReviewNode(steamId, html, reviewCount) {\r\n        const parser = new DOMParser();\r\n        const doc = parser.parseFromString(html, \"text/html\");\r\n        const node = doc.querySelector(\".review_box\");\r\n        const id = SteamCommunityApi._getReviewId(node);\r\n\r\n        if (!await IndexedDB.contains(\"reviews\", steamId, {\"preventFetch\": true})) { return null; }\r\n\r\n        const reviews = await IndexedDB.get(\"reviews\", steamId, {\"params\": reviewCount});\r\n\r\n        for (const review of reviews) {\r\n            if (review.id === id) {\r\n                review.node = DOMPurify.sanitize(node.outerHTML);\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Todo updates expiry even though there is no new fetched data\r\n        return IndexedDB.put(\"reviews\", {[steamId]: reviews});\r\n    }\r\n\r\n    static getReviews(steamId, reviewCount) {\r\n        return IndexedDB.get(\"reviews\", steamId, {\"params\": {reviewCount}});\r\n    }\r\n\r\n    /*\r\n     * Invoked when the content script thinks the user is logged in\r\n     * If we don't know the user's steamId, fetch their community profile\r\n     */\r\n    static async login(profilePath) {\r\n        const self = SteamCommunityApi;\r\n\r\n        if (!profilePath) {\r\n            self.logout();\r\n            throw new Error(\"Login endpoint needs a valid profile path\");\r\n        }\r\n        if (!profilePath.startsWith(\"/id/\") && !profilePath.startsWith(\"/profiles/\")) {\r\n            self.logout();\r\n            throw new Error(`Could not interpret ${profilePath} as a valid profile path`);\r\n        }\r\n\r\n        const login = LocalStorage.get(\"login\");\r\n        if (login && login.profilePath === profilePath) { return login; }\r\n\r\n        const html = await self.getPage(profilePath);\r\n        const profileData = HTMLParser.getVariableFromText(html, \"g_rgProfileData\", \"object\");\r\n        const steamId = profileData.steamid;\r\n\r\n        if (!steamId) { // this should never happen\r\n            throw new Error(\"Failed to retrieve steamID from profile\");\r\n        }\r\n\r\n        self.logout(true);\r\n\r\n        const value = {steamId, profilePath};\r\n        LocalStorage.set(\"login\", value);\r\n\r\n        return value;\r\n    }\r\n\r\n    static logout(newLogout = LocalStorage.has(\"login\")) {\r\n        if (newLogout) {\r\n            LocalStorage.remove(\"login\");\r\n            LocalStorage.remove(\"storeCountry\");\r\n            CacheStorage.remove(\"currency\");\r\n        }\r\n    }\r\n\r\n    // TODO This and (at least) the login calls don't seem appropriate in this class\r\n    static storeCountry(newCountry) {\r\n        if (newCountry) {\r\n            LocalStorage.set(\"storeCountry\", newCountry);\r\n            return null;\r\n        } else {\r\n            return LocalStorage.get(\"storeCountry\");\r\n        }\r\n    }\r\n\r\n    static getProfile(steamId) {\r\n        return IndexedDB.get(\"profiles\", steamId, {\"params\": {\"profile\": steamId}});\r\n    }\r\n\r\n    static clearOwn(steamId) {\r\n        return IndexedDB.delete(\"profiles\", steamId);\r\n    }\r\n\r\n    static async getPage(endpoint, query) {\r\n        const response = await this._fetchWithDefaults(endpoint, query, {\"method\": \"GET\"});\r\n        if (new URL(response.url).pathname === \"/login/home/\") {\r\n            throw new Errors.LoginError(\"community\");\r\n        }\r\n        return response.text();\r\n    }\r\n}\r\nSteamCommunityApi.origin = \"https://steamcommunity.com/\";\r\nSteamCommunityApi.params = {\"credentials\": \"include\"};\r\n\r\nexport {SteamCommunityApi};\r\n","import {HTMLParser} from \"../../Core/Html/HtmlParser\";\r\nimport {Errors} from \"../../Core/Errors/Errors\";\r\nimport {Api} from \"./Api\";\r\nimport {IndexedDB} from \"./IndexedDB\";\r\nimport {CacheStorage} from \"./CacheStorage\";\r\n\r\nclass SteamStoreApi extends Api {\r\n\r\n    /*\r\n     * static origin = \"https://store.steampowered.com/\";\r\n     * static params = { 'credentials': 'include', };\r\n     * static _progressingRequests = new Map();\r\n     */\r\n\r\n    static async fetchPackage({\"key\": subid}) {\r\n        const data = await SteamStoreApi.getEndpoint(\"/api/packagedetails/\", {\"packageids\": subid});\r\n        const appids = new Map();\r\n\r\n        for (const [subid, details] of Object.entries(data)) {\r\n            if (details && details.success) {\r\n\r\n                // .apps is an array of { 'id': ##, 'name': \"\", }\r\n                appids.set(Number(subid), details.data.apps.map(obj => obj.id));\r\n            } else {\r\n                appids.set(Number(subid), null);\r\n            }\r\n        }\r\n        return IndexedDB.put(\"packages\", appids);\r\n    }\r\n\r\n    static async wishlistAdd(appid) {\r\n        let res;\r\n        const sessionid = await SteamStoreApi.sessionId();\r\n\r\n        if (sessionid) {\r\n            res = await SteamStoreApi.postEndpoint(\"/api/addtowishlist\", {sessionid, appid});\r\n        }\r\n\r\n        if (!res || !res.success) {\r\n            throw new Error(`Failed to add app ${appid} to wishlist`);\r\n        }\r\n\r\n        return SteamStoreApi.clearDynamicStore();\r\n    }\r\n\r\n    static async wishlistRemove(appid, sessionid) {\r\n        let res;\r\n        let _sessionid = sessionid;\r\n\r\n        if (!_sessionid) {\r\n            _sessionid = await SteamStoreApi.sessionId();\r\n        }\r\n        if (_sessionid) {\r\n            res = await SteamStoreApi.postEndpoint(\"/api/removefromwishlist\", {\"sessionid\": _sessionid, appid});\r\n        }\r\n\r\n        if (!res || !res.success) {\r\n            throw new Error(`Failed to remove app ${appid} from wishlist`);\r\n        }\r\n\r\n        return SteamStoreApi.clearDynamicStore();\r\n    }\r\n\r\n    static async currencyFromWallet() {\r\n        const html = await SteamStoreApi.getPage(\"/steamaccount/addfunds\");\r\n        const dummyPage = HTMLParser.htmlToDOM(html);\r\n\r\n        return dummyPage.querySelector(\"input[name=currency]\").value;\r\n    }\r\n\r\n    static async currencyFromApp() {\r\n        const html = await SteamStoreApi.getPage(\"/app/220\");\r\n        const dummyPage = HTMLParser.htmlToDOM(html);\r\n\r\n        const currency = dummyPage.querySelector(\"meta[itemprop=priceCurrency][content]\");\r\n        if (!currency || !currency.getAttribute(\"content\")) {\r\n            throw new Error(\"Store currency could not be determined from app 220\");\r\n        }\r\n\r\n        return currency.getAttribute(\"content\");\r\n    }\r\n\r\n    static async currency() {\r\n        let currency = CacheStorage.get(\"currency\", 60 * 60);\r\n        if (currency) { return currency; }\r\n\r\n        currency = await SteamStoreApi.currencyFromWallet();\r\n        if (!currency) { currency = await SteamStoreApi.currencyFromApp(); }\r\n        if (!currency) { throw new Error(\"Could not retrieve store currency\"); }\r\n\r\n        CacheStorage.set(\"currency\", currency);\r\n        return currency;\r\n    }\r\n\r\n    /*\r\n     * Invoked if we were previously logged out and are now logged in\r\n     */\r\n    static async country() {\r\n        const self = SteamStoreApi;\r\n        const html = await self.getPage(\"/account/change_country/\", {}, res => {\r\n            if (new URL(res.url).pathname === \"/login/\") {\r\n                throw new Errors.LoginError(\"store\");\r\n            }\r\n        });\r\n        const dummyPage = HTMLParser.htmlToDOM(html);\r\n\r\n        const node = dummyPage.querySelector(\"#dselect_user_country\");\r\n        return node && node.value;\r\n    }\r\n\r\n    static async sessionId() {\r\n        const self = SteamStoreApi;\r\n\r\n        // TODO what's the minimal page we can load here to get sessionId?\r\n        const html = await self.getPage(\"/news/\");\r\n        return HTMLParser.getVariableFromText(html, \"g_sessionID\", \"string\");\r\n    }\r\n\r\n    static async wishlists(path) {\r\n        const html = await SteamStoreApi.getPage(`/wishlist${path}`);\r\n        const data = HTMLParser.getVariableFromText(html, \"g_rgWishlistData\", \"array\");\r\n        return data ? data.length : \"\";\r\n    }\r\n\r\n    static async purchaseDate({\"params\": lang}) {\r\n        const replaceRegex = [\r\n            /- Complete Pack/ig,\r\n            /Standard Edition/ig,\r\n            /Steam Store and Retail Key/ig,\r\n            /- Hardware Survey/ig,\r\n            /ComputerGamesRO -/ig,\r\n            /Founder Edition/ig,\r\n            /Retail( Key)?/ig,\r\n            /Complete$/ig,\r\n            /Launch$/ig,\r\n            /Free$/ig,\r\n            /(RoW)/ig,\r\n            /ROW/ig,\r\n            /:/ig,\r\n        ];\r\n        const purchaseDates = new Map();\r\n\r\n        const html = await SteamStoreApi.getPage(\"/account/licenses/\", {\"l\": lang});\r\n        const dummyPage = HTMLParser.htmlToDOM(html);\r\n        const nodes = dummyPage.querySelectorAll(\"#main_content td.license_date_col\");\r\n        for (const node of nodes) {\r\n            const name = node.nextElementSibling;\r\n            const removeNode = name.querySelector(\"div\");\r\n            if (removeNode) { removeNode.remove(); }\r\n\r\n            let appName = HTMLParser.clearSpecialSymbols(name.textContent.trim());\r\n            for (const regex of replaceRegex) {\r\n                appName = appName.replace(regex, \"\");\r\n            }\r\n            appName = appName.trim();\r\n            purchaseDates.set(appName, node.textContent);\r\n        }\r\n\r\n        return IndexedDB.put(\"purchases\", purchaseDates);\r\n    }\r\n\r\n    static purchases(appName, lang) { return IndexedDB.get(\"purchases\", appName, {\"params\": lang}); }\r\n    static clearPurchases() { return IndexedDB.clear(\"purchases\"); }\r\n\r\n    static async dynamicStore() {\r\n        const store = await SteamStoreApi.getEndpoint(\"dynamicstore/userdata\", {}, null, {\"cache\": \"no-cache\"});\r\n        const {rgOwnedApps, rgOwnedPackages, rgIgnoredApps, rgWishlist} = store;\r\n\r\n        const dynamicStore = {\r\n            \"ignored\": Object.keys(rgIgnoredApps).map(key => Number(key)),\r\n            \"ownedApps\": rgOwnedApps,\r\n            \"ownedPackages\": rgOwnedPackages,\r\n            \"wishlisted\": rgWishlist,\r\n        };\r\n\r\n        /*\r\n         * dynamicstore keys are:\r\n         * \"rgWishlist\", \"rgOwnedPackages\", \"rgOwnedApps\", \"rgPackagesInCart\", \"rgAppsInCart\"\r\n         * \"rgRecommendedTags\", \"rgIgnoredApps\", \"rgIgnoredPackages\", \"rgCurators\", \"rgCurations\"\r\n         * \"rgCreatorsFollowed\", \"rgCreatorsIgnored\", \"preferences\", \"rgExcludedTags\",\r\n         * \"rgExcludedContentDescriptorIDs\", \"rgAutoGrantApps\"\r\n         */\r\n\r\n        return IndexedDB.put(\"dynamicStore\", dynamicStore);\r\n    }\r\n\r\n    static dsStatus(ids) {\r\n        return IndexedDB.getFromIndex(\"dynamicStore\", \"appid\", ids, {\"all\": true, \"asKey\": true});\r\n    }\r\n\r\n    static async dynamicStoreRandomApp() {\r\n        const store = await IndexedDB.getAll(\"dynamicStore\");\r\n        if (!store || !store.ownedApps) { return null; }\r\n        return store.ownedApps[Math.floor(Math.random() * store.ownedApps.length)];\r\n    }\r\n\r\n    static async clearDynamicStore() {\r\n        await IndexedDB.clear(\"dynamicStore\");\r\n    }\r\n\r\n    static appDetails(appid, filter) {\r\n        const params = {\"appids\": appid};\r\n        if (filter) { params.filters = filter; }\r\n\r\n        return SteamStoreApi.endpointFactory(\"api/appdetails/\", appid)(params);\r\n    }\r\n\r\n    static appUserDetails(appid) { return SteamStoreApi.endpointFactory(\"api/appuserdetails/\", appid)({\"appids\": appid}); }\r\n}\r\nSteamStoreApi.origin = \"https://store.steampowered.com/\";\r\nSteamStoreApi.params = {\"credentials\": \"include\"};\r\nSteamStoreApi._progressingRequests = new Map();\r\n\r\nexport {SteamStoreApi};\r\n","import {ExtensionResources} from \"../../Core/ExtensionResources\";\r\n\r\nclass StaticResources {\r\n\r\n    static async currencies() {\r\n        const self = StaticResources;\r\n        if (!self._supportedCurrencies || self._supportedCurrencies.length < 1) {\r\n\r\n            /**\r\n             * https://partner.steamgames.com/doc/store/pricing/currencies\r\n             */\r\n            self._supportedCurrencies = await ExtensionResources.getJSON(\"json/currency.json\");\r\n        }\r\n        return self._supportedCurrencies;\r\n    }\r\n}\r\nStaticResources._supportedCurrencies = null;\r\n\r\n\r\nexport {StaticResources};\r\n","// This is the basic configuration for the Augmented Steam extension\r\n\r\nexport default {\r\n    \"ApiServerHost\": \"https://esapi.isthereanydeal.com\",\r\n    \"PublicHost\": \"https://augmentedsteam.com\",\r\n    \"ITADApiServerHost\": \"https://api.isthereanydeal.com\",\r\n    \"ITADClientId\": \"5fe78af07889f43a\"\r\n};\r\n","import {LocalStorage} from \"../../Core/Storage/LocalStorage\";\r\nimport {TimeUtils} from \"../../Core/Utils/TimeUtils\";\r\nimport {SyncedStorage} from \"../../Core/Storage/SyncedStorage\";\r\nimport {Api} from \"./Api\";\r\nimport Config from \"../../config\";\r\nimport {IndexedDB} from \"./IndexedDB\";\r\n\r\nclass ITADApi extends Api {\r\n\r\n    static async authorize() {\r\n        const rnd = crypto.getRandomValues(new Uint32Array(1))[0];\r\n        const redirectURI = \"https://isthereanydeal.com/connectaugmentedsteam\";\r\n\r\n        const authUrl = new URL(`${Config.ITADApiServerHost}/oauth/authorize/`);\r\n        authUrl.searchParams.set(\"client_id\", Config.ITADClientId);\r\n        authUrl.searchParams.set(\"response_type\", \"token\");\r\n        authUrl.searchParams.set(\"state\", rnd);\r\n        authUrl.searchParams.set(\"scope\", ITADApi.requiredScopes.join(\" \"));\r\n        authUrl.searchParams.set(\"redirect_uri\", redirectURI);\r\n\r\n        const tab = await browser.tabs.create({\"url\": authUrl.toString()});\r\n\r\n        const url = await new Promise((resolve, reject) => {\r\n            function webRequestListener({url}) {\r\n                resolve(url);\r\n\r\n                browser.webRequest.onBeforeRequest.removeListener(webRequestListener);\r\n                // eslint-disable-next-line no-use-before-define -- Circular dependency\r\n                browser.tabs.onRemoved.removeListener(tabsListener);\r\n\r\n                browser.tabs.remove(tab.id);\r\n                return {\"cancel\": true};\r\n            }\r\n\r\n            function tabsListener(tabId) {\r\n                if (tabId === tab.id) {\r\n                    reject(new Error(\"Authorization tab closed\"));\r\n\r\n                    browser.webRequest.onBeforeRequest.removeListener(webRequestListener);\r\n                    browser.tabs.onRemoved.removeListener(tabsListener);\r\n                }\r\n            }\r\n\r\n            browser.webRequest.onBeforeRequest.addListener(\r\n                webRequestListener,\r\n                {\r\n                    \"urls\": [\r\n                        redirectURI, // For Chrome, seems to not support match patterns (a problem with the Polyfill?)\r\n                        `${redirectURI}#*` // For Firefox\r\n                    ],\r\n                    \"tabId\": tab.id\r\n                },\r\n                [\"blocking\"]\r\n            );\r\n            browser.tabs.onRemoved.addListener(tabsListener);\r\n        });\r\n\r\n        const hashFragment = new URL(url).hash;\r\n        const params = new URLSearchParams(hashFragment.substr(1));\r\n\r\n        if (parseInt(params.get(\"state\")) !== rnd) {\r\n            throw new Error(\"Failed to verify state parameter from URL fragment\");\r\n        }\r\n\r\n        const accessToken = params.get(\"access_token\");\r\n        const expiresIn = params.get(\"expires_in\");\r\n\r\n        if (!accessToken || !expiresIn) {\r\n            throw new Error(`Couldn't retrieve information from URL fragment \"${hashFragment}\"`);\r\n        }\r\n\r\n        LocalStorage.set(\"access_token\", {\r\n            \"token\": accessToken,\r\n            \"expiry\": TimeUtils.now() + parseInt(expiresIn)\r\n        });\r\n    }\r\n\r\n    static disconnect() {\r\n        LocalStorage.remove(\"access_token\");\r\n        LocalStorage.remove(\"lastItadImport\");\r\n        return IndexedDB.clear([\"collection\", \"waitlist\", \"itadImport\"]);\r\n    }\r\n\r\n    static isConnected() {\r\n        const lsEntry = LocalStorage.get(\"access_token\");\r\n        if (!lsEntry) { return false; }\r\n\r\n        if (lsEntry.expiry <= TimeUtils.now()) {\r\n            LocalStorage.remove(\"access_token\");\r\n            return false;\r\n        }\r\n        ITADApi.accessToken = lsEntry.token;\r\n\r\n        return true;\r\n    }\r\n\r\n    static endpointFactoryCached(endpoint, storeName, resultFn) {\r\n        return ({params = {}, key} = {}) => {\r\n            if (ITADApi.isConnected()) {\r\n                return super.endpointFactoryCached(endpoint, storeName, resultFn)(\r\n                    {\"params\": Object.assign(params, {\"access_token\": ITADApi.accessToken}), key}\r\n                );\r\n            }\r\n            return null;\r\n        };\r\n    }\r\n\r\n    static async addToWaitlist(appids) {\r\n        if (!appids || (Array.isArray(appids) && !appids.length)) {\r\n            console.warn(\"Can't add nothing to ITAD waitlist\");\r\n            return null;\r\n        }\r\n\r\n        const waitlistJSON = {\r\n            \"version\": \"02\",\r\n            \"data\": [],\r\n        };\r\n\r\n        const storeids = {};\r\n        if (Array.isArray(appids)) {\r\n            appids.forEach(appid => {\r\n                const id = `app/${appid}`;\r\n                waitlistJSON.data.push({\r\n                    \"gameid\": [\"steam\", id],\r\n                });\r\n                storeids[id] = null;\r\n            });\r\n        } else {\r\n            const id = `app/${appids}`;\r\n            waitlistJSON.data[0] = {\r\n                \"gameid\": [\"steam\", id],\r\n            };\r\n            storeids[id] = null;\r\n        }\r\n\r\n        await ITADApi.postEndpoint(\r\n            \"v01/waitlist/import/\",\r\n            {\"access_token\": ITADApi.accessToken},\r\n            null,\r\n            {\"body\": JSON.stringify(waitlistJSON)}\r\n        );\r\n\r\n        return IndexedDB.put(\"waitlist\", storeids);\r\n    }\r\n\r\n    static async removeFromWaitlist(appids) {\r\n        if (!appids || (Array.isArray(appids) && !appids.length)) {\r\n            throw new Error(\"Can't remove nothing from ITAD Waitlist!\");\r\n        }\r\n\r\n        const _appids = Array.isArray(appids) ? appids : [appids];\r\n        const storeids = _appids.map(appid => `app/${appid}`);\r\n\r\n        await ITADApi.deleteEndpoint(\r\n            \"v02/user/wait/remove/\",\r\n            {\"access_token\": ITADApi.accessToken, \"shop\": \"steam\", \"ids\": storeids.join()}\r\n        );\r\n\r\n        return IndexedDB.delete(\"waitlist\", storeids);\r\n    }\r\n\r\n    static addToCollection(appids, subids) {\r\n        if ((!appids || (Array.isArray(appids) && !appids.length)) && (!subids || (Array.isArray(subids) && !subids.length))) {\r\n            console.warn(\"Can't add nothing to ITAD collection\");\r\n            return null;\r\n        }\r\n\r\n        const collectionJSON = {\r\n            \"version\": \"02\",\r\n            \"data\": [],\r\n        };\r\n\r\n        let _appids;\r\n        if (Array.isArray(appids)) {\r\n            _appids = appids;\r\n        } else if (appids) {\r\n            _appids = [appids];\r\n        } else {\r\n            _appids = [];\r\n        }\r\n\r\n        let _subids;\r\n        if (Array.isArray(subids)) {\r\n            _subids = subids;\r\n        } else if (subids) {\r\n            _subids = [subids];\r\n        } else {\r\n            _subids = [];\r\n        }\r\n\r\n        const storeids = _appids.map(appid => `app/${appid}`).concat(_subids.map(subid => `sub/${subid}`));\r\n        for (const storeid of storeids) {\r\n            collectionJSON.data.push({\r\n                \"gameid\": [\"steam\", storeid],\r\n                \"copies\": [{\r\n                    \"type\": \"steam\",\r\n                    \"status\": \"redeemed\",\r\n                    \"owned\": 1,\r\n                }],\r\n            });\r\n        }\r\n\r\n        return ITADApi.postEndpoint(\r\n            \"v01/collection/import/\",\r\n            {\"access_token\": ITADApi.accessToken},\r\n            null,\r\n            {\"body\": JSON.stringify(collectionJSON)}\r\n        );\r\n    }\r\n\r\n    static async import(force) {\r\n\r\n        if (force) {\r\n            await IndexedDB.clear(\"dynamicStore\");\r\n        } else {\r\n            const lastImport = LocalStorage.get(\"lastItadImport\");\r\n\r\n            if (lastImport && lastImport.to && !IndexedDB.isExpired(lastImport.to + (12 * 60 * 60))) { return; }\r\n        }\r\n\r\n        const dsKeys = [];\r\n        const itadImportKeys = [];\r\n        if (SyncedStorage.get(\"itad_import_library\")) {\r\n            dsKeys.push(\"ownedApps\", \"ownedPackages\");\r\n            itadImportKeys.push(\"lastOwnedApps\", \"lastOwnedPackages\");\r\n        }\r\n\r\n        if (SyncedStorage.get(\"itad_import_wishlist\")) {\r\n            dsKeys.push(\"wishlisted\");\r\n            itadImportKeys.push(\"lastWishlisted\");\r\n        }\r\n\r\n        const result = await Promise.all([\r\n            IndexedDB.get(\"dynamicStore\", dsKeys),\r\n            IndexedDB.get(\"itadImport\", itadImportKeys),\r\n        ]);\r\n\r\n        function removeDuplicates(from, other) {\r\n            if (!from) { return []; }\r\n            if (!other) { return from; }\r\n            return from.filter(el => !other.includes(el));\r\n        }\r\n\r\n        const promises = [];\r\n\r\n        if (SyncedStorage.get(\"itad_import_library\")) {\r\n            const [{ownedApps, ownedPackages}, {lastOwnedApps, lastOwnedPackages}] = result;\r\n            const newOwnedApps = removeDuplicates(ownedApps, lastOwnedApps);\r\n            const newOwnedPackages = removeDuplicates(ownedPackages, lastOwnedPackages);\r\n            if (newOwnedApps.length || newOwnedPackages.length) {\r\n                promises.push(ITADApi.addToCollection(newOwnedApps, newOwnedPackages)\r\n                    .then(() => IndexedDB.put(\"itadImport\", {\r\n                        \"lastOwnedApps\": ownedApps,\r\n                        \"lastOwnedPackages\": ownedPackages,\r\n                    })));\r\n            }\r\n        }\r\n\r\n        if (SyncedStorage.get(\"itad_import_wishlist\")) {\r\n            const [{wishlisted}, {lastWishlisted}] = result;\r\n            const newWishlisted = removeDuplicates(wishlisted, lastWishlisted);\r\n            if (newWishlisted.length) {\r\n                promises.push(ITADApi.addToWaitlist(newWishlisted)\r\n                    .then(() => IndexedDB.put(\"itadImport\", {\"lastWishlisted\": wishlisted})));\r\n            }\r\n        }\r\n\r\n        await Promise.all(promises);\r\n\r\n        const lastImport = LocalStorage.get(\"lastItadImport\") || {};\r\n        lastImport.to = TimeUtils.now();\r\n        LocalStorage.set(\"lastItadImport\", lastImport);\r\n    }\r\n\r\n    static async sync() {\r\n        await Promise.all([\r\n            ITADApi.import(true),\r\n            IndexedDB.clear(\"waitlist\").then(\r\n                () => IndexedDB.objStoreFetchFns.get(\"waitlist\")(\r\n                    {\"params\": {\"shop\": \"steam\", \"optional\": \"gameid\"}}\r\n                )\r\n            ),\r\n            IndexedDB.clear(\"collection\").then(\r\n                () => IndexedDB.objStoreFetchFns.get(\"collection\")(\r\n                    {\"params\": {\"shop\": \"steam\", \"optional\": \"gameid,copy_type\"}}\r\n                )\r\n            ),\r\n        ]);\r\n    }\r\n\r\n    static lastImport() { return LocalStorage.get(\"lastItadImport\"); }\r\n\r\n    static mapCollection(result) {\r\n        if (!result) { return null; }\r\n        const {games, typemap} = result;\r\n\r\n        const collection = {};\r\n        games.forEach(({gameid, types}) => {\r\n            const _types = types.map(type => typemap[type]);\r\n\r\n            collection[gameid] = _types;\r\n        });\r\n\r\n        const lastImport = LocalStorage.get(\"lastItadImport\") || {};\r\n        lastImport.from = TimeUtils.now();\r\n        LocalStorage.set(\"lastItadImport\", lastImport);\r\n\r\n        return collection;\r\n    }\r\n\r\n    static mapWaitlist(result) {\r\n        if (!result) { return null; }\r\n\r\n        const waitlist = [];\r\n        for (const {gameid} of Object.values(result)) {\r\n            waitlist.push(gameid);\r\n        }\r\n\r\n        const lastImport = LocalStorage.get(\"lastItadImport\") || {};\r\n        lastImport.from = TimeUtils.now();\r\n        LocalStorage.set(\"lastItadImport\", lastImport);\r\n\r\n        return waitlist;\r\n    }\r\n\r\n    static inWaitlist(storeIds) {\r\n        return IndexedDB.contains(\"waitlist\", storeIds, {\"params\": {\"shop\": \"steam\", \"optional\": \"gameid\"}});\r\n    }\r\n\r\n    static inCollection(storeIds) {\r\n        return IndexedDB.contains(\"collection\", storeIds, {\"params\": {\"shop\": \"steam\", \"optional\": \"gameid,copy_type\"}});\r\n    }\r\n\r\n    static getFromCollection(storeId) {\r\n        return IndexedDB.get(\"collection\", storeId, {\"params\": {\"shop\": \"steam\", \"optional\": \"gameid,copy_type\"}});\r\n    }\r\n}\r\nITADApi.accessToken = null;\r\nITADApi.requiredScopes = [\r\n    \"wait_read\",\r\n    \"wait_write\",\r\n    \"coll_read\",\r\n    \"coll_write\",\r\n];\r\n\r\nITADApi.origin = Config.ITADApiServerHost;\r\nITADApi._progressingRequests = new Map();\r\n\r\nexport {ITADApi};\r\n","import {Errors} from \"../../Core/Errors/Errors\";\r\nimport {IndexedDB} from \"./IndexedDB\";\r\nimport Config from \"../../config\";\r\nimport {Api} from \"./Api\";\r\n\r\nclass AugmentedSteamApi extends Api {\r\n\r\n    /*\r\n     * static origin = Config.ApiServerHost;\r\n     * static _progressingRequests = new Map();\r\n     */\r\n\r\n    static async getEndpoint(endpoint, query) { // withResponse? boolean that includes Response object in result?\r\n        const json = await super.getEndpoint(endpoint, query, response => {\r\n            if (response.status === 500) {\r\n\r\n                /*\r\n                 * Beautify HTTP 500: \"User 'p_enhsteam' has exceeded the 'max_user_connections' resource (current value: XX)\",\r\n                 * which would result in a SyntaxError due to JSON.parse\r\n                 */\r\n                throw new Errors.ServerOutageError(\r\n                    `Augmented Steam servers are currently overloaded, failed to fetch endpoint \"${endpoint}\"`\r\n                );\r\n            }\r\n        });\r\n        if (!json.result || json.result !== \"success\") {\r\n            throw new Error(`Could not retrieve '${endpoint}'`);\r\n        }\r\n        delete json.result;\r\n        return json;\r\n    }\r\n\r\n    static storePageData(appid, metalink, showoc) {\r\n        const params = {\"appid\": appid};\r\n        if (metalink) { params.mcurl = metalink; }\r\n        if (showoc) { params.oc = 1; }\r\n        return IndexedDB.get(\"storePageData\", appid, {params});\r\n    }\r\n\r\n    static expireStorePageData(appid) {\r\n        return IndexedDB.delete(\"storePageData\", `app_${appid}`);\r\n    }\r\n\r\n    static rates(to) {\r\n        return IndexedDB.getAll(\"rates\", {\"params\": {\"to\": to.sort().join(\",\")}});\r\n    }\r\n\r\n    static isEA(appids) {\r\n        return IndexedDB.contains(\"earlyAccessAppids\", appids);\r\n    }\r\n\r\n    static steamPeek(appid) {\r\n        return AugmentedSteamApi.endpointFactory(\"v01/similar\")({appid, \"count\": 15});\r\n    }\r\n}\r\nAugmentedSteamApi.origin = Config.ApiServerHost;\r\nAugmentedSteamApi._progressingRequests = new Map();\r\n\r\nexport {AugmentedSteamApi};\r\n","import {SyncedStorage} from \"../../Core/Storage/SyncedStorage\";\r\nimport {IndexedDB} from \"./IndexedDB\";\r\nimport {CacheStorage} from \"./CacheStorage\";\r\n\r\nclass ExtensionData {\r\n    static clearCache() {\r\n        CacheStorage.clear();\r\n        return IndexedDB.clear();\r\n    }\r\n\r\n    /*\r\n     * TEMP(1.4.1)\r\n     * TODO delete after few versions\r\n     */\r\n    static async moveNotesToSyncedStorage() {\r\n        const idbNotes = Object.entries(await IndexedDB.getAll(\"notes\"));\r\n\r\n        const notes = SyncedStorage.get(\"user_notes\");\r\n        for (const [appid, note] of idbNotes) {\r\n            notes[appid] = note;\r\n        }\r\n        SyncedStorage.set(\"user_notes\", notes);\r\n    }\r\n\r\n    static getNote(appid) {\r\n        return IndexedDB.get(\"notes\", appid);\r\n    }\r\n\r\n    static setNote(appid, note) {\r\n        // Preserve the integer appid\r\n        return IndexedDB.put(\"notes\", new Map([[appid, note]]));\r\n    }\r\n\r\n    static deleteNote(appid) {\r\n        return IndexedDB.delete(\"notes\", appid);\r\n    }\r\n\r\n    static getAllNotes() {\r\n        return IndexedDB.getAll(\"notes\");\r\n    }\r\n\r\n    static async setAllNotes(notes) {\r\n        await ExtensionData.clearNotes();\r\n\r\n        // Preserve the integer appid\r\n        const map = new Map(Object.entries(notes).map(([appid, note]) => [Number(appid), note]));\r\n        return IndexedDB.put(\"notes\", map);\r\n    }\r\n\r\n    static clearNotes() {\r\n        return IndexedDB.clear(\"notes\");\r\n    }\r\n}\r\n\r\nexport {ExtensionData};\r\n","import setup from \"../setup\";\r\nimport {Permissions, SyncedStorage} from \"../modulesCore\";\r\nimport {ContextMenu} from \"./Modules/ContextMenu\";\r\nimport {IndexedDB} from \"./Modules/IndexedDB\";\r\nimport {SteamCommunityApi} from \"./Modules/SteamCommunityApi\";\r\nimport {SteamStoreApi} from \"./Modules/SteamStoreApi\";\r\nimport {StaticResources} from \"./Modules/StaticResources\";\r\nimport {ITADApi} from \"./Modules/ITADApi\";\r\nimport {AugmentedSteamApi} from \"./Modules/AugmentedSteamApi\";\r\nimport {ExtensionData} from \"./Modules/ExtensionData\";\r\n\r\n// Functions that are called when an object store (or one of its entries) has expired\r\nIndexedDB.objStoreFetchFns = new Map([\r\n    [\"coupons\", SteamCommunityApi.coupons],\r\n    [\"giftsAndPasses\", SteamCommunityApi.giftsAndPasses],\r\n    [\"items\", SteamCommunityApi.items],\r\n    [\"workshopFileSizes\", SteamCommunityApi.fetchWorkshopFileSize],\r\n    [\"reviews\", SteamCommunityApi.fetchReviews],\r\n\r\n    [\"purchases\", SteamStoreApi.purchaseDate],\r\n    [\"dynamicStore\", SteamStoreApi.dynamicStore],\r\n    [\"packages\", SteamStoreApi.fetchPackage],\r\n\r\n    [\"earlyAccessAppids\", AugmentedSteamApi.endpointFactoryCached(\"v01/earlyaccess\", \"earlyAccessAppids\")],\r\n    [\"storePageData\", AugmentedSteamApi.endpointFactoryCached(\"v01/storepagedata\", \"storePageData\")],\r\n    [\"profiles\", AugmentedSteamApi.endpointFactoryCached(\"v01/profile/profile\", \"profiles\")],\r\n    [\"rates\", AugmentedSteamApi.endpointFactoryCached(\"v01/rates\", \"rates\")],\r\n\r\n    [\"collection\", ITADApi.endpointFactoryCached(\"v02/user/coll/all\", \"collection\", ITADApi.mapCollection)],\r\n    [\"waitlist\", ITADApi.endpointFactoryCached(\"v01/user/wait/all\", \"waitlist\", ITADApi.mapWaitlist)],\r\n]);\r\n\r\nconst actionCallbacks = new Map([\r\n    [\"wishlist.add\", SteamStoreApi.wishlistAdd],\r\n    [\"wishlist.remove\", SteamStoreApi.wishlistRemove],\r\n    [\"dynamicstore.clear\", SteamStoreApi.clearDynamicStore],\r\n\r\n    [\"steam.currencies\", StaticResources.currencies],\r\n\r\n    [\"migrate.notesToSyncedStorage\", ExtensionData.moveNotesToSyncedStorage],\r\n    [\"notes.get\", ExtensionData.getNote],\r\n    [\"notes.set\", ExtensionData.setNote],\r\n    [\"notes.delete\", ExtensionData.deleteNote],\r\n    [\"notes.getall\", ExtensionData.getAllNotes],\r\n    [\"notes.setall\", ExtensionData.setAllNotes],\r\n    [\"notes.clear\", ExtensionData.clearNotes],\r\n    [\"cache.clear\", ExtensionData.clearCache],\r\n\r\n    [\"dlcinfo\", AugmentedSteamApi.endpointFactory(\"v01/dlcinfo\")],\r\n    [\"storepagedata\", AugmentedSteamApi.storePageData],\r\n    [\"storepagedata.expire\", AugmentedSteamApi.expireStorePageData],\r\n    [\"prices\", AugmentedSteamApi.endpointFactory(\"v01/prices\")],\r\n    [\"rates\", AugmentedSteamApi.rates],\r\n    [\"isea\", AugmentedSteamApi.isEA],\r\n    [\"profile.background\", AugmentedSteamApi.endpointFactory(\"v01/profile/background/background\")],\r\n    [\"profile.background.games\", AugmentedSteamApi.endpointFactory(\"v01/profile/background/games\")],\r\n    [\"twitch.stream\", AugmentedSteamApi.endpointFactory(\"v01/twitch/stream\")],\r\n    [\"market.cardprices\", AugmentedSteamApi.endpointFactory(\"v01/market/cardprices\")],\r\n    [\"market.averagecardprice\", AugmentedSteamApi.endpointFactory(\"v01/market/averagecardprice\")], // FIXME deprecated\r\n    [\"market.averagecardprices\", AugmentedSteamApi.endpointFactory(\"v01/market/averagecardprices\")],\r\n    [\"steampeek\", AugmentedSteamApi.steamPeek],\r\n\r\n    [\"appdetails\", SteamStoreApi.appDetails],\r\n    [\"appuserdetails\", SteamStoreApi.appUserDetails],\r\n    [\"currency\", SteamStoreApi.currency],\r\n    [\"sessionid\", SteamStoreApi.sessionId],\r\n    [\"wishlists\", SteamStoreApi.wishlists],\r\n    [\"purchases\", SteamStoreApi.purchases],\r\n    [\"clearpurchases\", SteamStoreApi.clearPurchases],\r\n    [\"dynamicstorestatus\", SteamStoreApi.dsStatus],\r\n    [\"dynamicStore.randomApp\", SteamStoreApi.dynamicStoreRandomApp],\r\n\r\n    [\"login\", SteamCommunityApi.login],\r\n    [\"logout\", SteamCommunityApi.logout],\r\n    [\"storecountry\", SteamCommunityApi.storeCountry],\r\n    [\"cards\", SteamCommunityApi.cards],\r\n    [\"stats\", SteamCommunityApi.stats],\r\n    [\"coupon\", SteamCommunityApi.getCoupon],\r\n    [\"hasgiftsandpasses\", SteamCommunityApi.hasGiftsAndPasses],\r\n    [\"hascoupon\", SteamCommunityApi.hasCoupon],\r\n    [\"hasitem\", SteamCommunityApi.hasItem],\r\n    [\"profile\", SteamCommunityApi.getProfile],\r\n    [\"clearownprofile\", SteamCommunityApi.clearOwn],\r\n    [\"workshopfilesize\", SteamCommunityApi.getWorkshopFileSize],\r\n    [\"reviews\", SteamCommunityApi.getReviews],\r\n    [\"updatereviewnode\", SteamCommunityApi.updateReviewNode],\r\n\r\n    [\"itad.authorize\", ITADApi.authorize],\r\n    [\"itad.disconnect\", ITADApi.disconnect],\r\n    [\"itad.isconnected\", ITADApi.isConnected],\r\n    [\"itad.import\", ITADApi.import],\r\n    [\"itad.sync\", ITADApi.sync],\r\n    [\"itad.lastimport\", ITADApi.lastImport],\r\n    [\"itad.inwaitlist\", ITADApi.inWaitlist],\r\n    [\"itad.addtowaitlist\", ITADApi.addToWaitlist],\r\n    [\"itad.removefromwaitlist\", ITADApi.removeFromWaitlist],\r\n    [\"itad.incollection\", ITADApi.inCollection],\r\n    [\"itad.getfromcollection\", ITADApi.getFromCollection],\r\n\r\n    [\"error.test\", () => { return Promise.reject(new Error(\"This is a TEST Error. Please ignore.\")); }],\r\n]);\r\n\r\n/*\r\n * new Map() for Map.prototype.get() in lieu of:\r\n * Object.prototype.hasOwnProperty.call(actionCallbacks, message.action)\r\n */\r\n\r\nbrowser.runtime.onMessage.addListener(async(message, sender) => {\r\n    if (!sender || !sender.tab) { return null; } // not from a tab, ignore\r\n    if (!message || !message.action) { return null; }\r\n\r\n    const callback = actionCallbacks.get(message.action);\r\n    if (!callback) {\r\n\r\n        // requested action not recognized, reply with error immediately\r\n        throw new Error(`Did not recognize \"${message.action}\" as an action.`);\r\n    }\r\n\r\n    message.params = message.params || [];\r\n    let res;\r\n    try {\r\n        await Promise.all([IndexedDB, SyncedStorage.then(() => { setup(); })]);\r\n        res = await callback(...message.params);\r\n    } catch (err) {\r\n        console.group(`Callback: \"${message.action}\"`);\r\n        console.error('Failed to execute callback \"%s\" with params %o', message.action, message.params);\r\n        console.error(err);\r\n        console.groupEnd();\r\n\r\n        throw new Error(err.toString());\r\n    }\r\n    return res;\r\n});\r\n\r\nbrowser.runtime.onStartup.addListener(ContextMenu.update);\r\nbrowser.runtime.onInstalled.addListener(ContextMenu.update);\r\n\r\nPermissions.when(\"contextMenus\", () => {\r\n    browser.contextMenus.onClicked.addListener(ContextMenu.onClick);\r\n}, () => {\r\n    browser.contextMenus.onClicked.removeListener(ContextMenu.onClick);\r\n});\r\n"],"sourceRoot":""}