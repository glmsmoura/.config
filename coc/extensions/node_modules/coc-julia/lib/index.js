var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = {exports: {}}).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function checkPathExt(path2, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path2.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path2, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path2, options);
    }
    function isexe(path2, options, cb) {
      fs2.stat(path2, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path2, options));
      });
    }
    function sync(path2, options) {
      return checkStat(fs2.statSync(path2), path2, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = require("fs");
    function isexe(path2, options, cb) {
      fs2.stat(path2, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path2, options) {
      return checkStat(fs2.statSync(path2), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports, module2) {
    var fs2 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path2, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path2, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path2, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path2, options) {
      try {
        return core.sync(path2, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports, module2) {
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path2 = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which2 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, {pathExt: pathExtExe});
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// src/index.ts
__markAsModule(exports);
__export(exports, {
  activate: () => activate
});
var import_coc2 = __toModule(require("coc.nvim"));

// src/ctx.ts
var import_child_process = __toModule(require("child_process"));
var import_coc = __toModule(require("coc.nvim"));
var import_fs = __toModule(require("fs"));
var import_os = __toModule(require("os"));
var import_path = __toModule(require("path"));
var import_util = __toModule(require("util"));
var import_which = __toModule(require_which());
var execPromise = (0, import_util.promisify)(import_child_process.exec);
var Config = class {
  constructor() {
    this.cfg = import_coc.workspace.getConfiguration("julia");
  }
  get enabled() {
    return this.cfg.get("enabled");
  }
  get executablePath() {
    return this.cfg.get("executablePath");
  }
  get environmentPath() {
    return this.cfg.get("environmentPath");
  }
};
var Ctx = class {
  constructor(context) {
    this.context = context;
    this.config = new Config();
    this.lsProj = import_path.default.join(context.extensionPath, "server", "JuliaLS");
    this.mainJulia = import_path.default.join(context.extensionPath, "server", "JuliaLS/src/main.jl");
    this.compileEnv = import_path.default.join(context.extensionPath, "server", "compile_env");
    if (!import_fs.default.existsSync(context.storagePath)) {
      import_fs.default.mkdirSync(context.storagePath);
    }
    this.serverRoot = import_path.default.join(context.storagePath, "JuliaLS");
    if (!import_fs.default.existsSync(this.serverRoot)) {
      import_fs.default.mkdirSync(this.serverRoot);
    }
    this.sysimgDir = import_path.default.join(context.storagePath, "sysimg");
    if (!import_fs.default.existsSync(this.sysimgDir)) {
      import_fs.default.mkdirSync(this.sysimgDir);
    }
  }
  resolveJuliaBin() {
    let bin = this.config.executablePath;
    if (bin.startsWith("~")) {
      bin = import_os.default.homedir() + bin.slice(1);
    }
    if (bin && import_fs.default.existsSync(bin)) {
      return bin;
    }
    const cmd = process.platform === "win32" ? "julia.exe" : "julia";
    return import_which.default.sync(cmd, {nothrow: true});
  }
  formatPkg(vals) {
    const pkgs = [];
    for (const val of vals) {
      const parts = val.split(" ");
      if (parts.length === 4 || parts.length === 5) {
        pkgs.push({
          state: parts[0],
          hash: parts[1],
          name: parts[2],
          version: parts[3],
          repo: parts[4] || ""
        });
      }
    }
    return pkgs;
  }
  async resolveMissingPkgs(projPath) {
    const bin = this.resolveJuliaBin();
    let cmd = `${bin} --project="${projPath}" --startup-file=no --history-file=no -e "using Pkg; Pkg.status()"`;
    const pkgs = this.formatPkg((await execPromise(cmd)).stderr.split("\n"));
    if (pkgs.some((p) => p.state === "\u2192")) {
      const projName = import_path.default.basename(projPath);
      const ok = await import_coc.window.showPrompt(`Some ${projName} deps are missing, would you like to install now?`);
      if (ok) {
        cmd = `${bin} --project="${projPath}" --startup-file=no --history-file=no -e "using Pkg; Pkg.instantiate()"`;
        await import_coc.workspace.createTerminal({name: "coc-julia-ls"}).then((t) => t.sendText(cmd));
      }
    }
  }
  async resolveEnvPath() {
    if (this.config.environmentPath) {
      return this.config.environmentPath;
    }
    const bin = this.resolveJuliaBin();
    const cmd = `${bin} --project=@. --startup-file=no --history-file=no -e "using Pkg; println(dirname(Pkg.Types.Context().env.project_file))"`;
    return (await execPromise(cmd)).stdout.trim();
  }
  async resolveSysimgPath() {
    let sysimg_name = "sysimg.so";
    switch (process.platform) {
      case "win32":
        sysimg_name = "sysimg.dll";
        break;
      case "darwin":
        sysimg_name = "sysimg.dylib";
        break;
    }
    const sysimg = import_path.default.join(this.sysimgDir, sysimg_name);
    if (import_fs.default.existsSync(sysimg)) {
      return sysimg;
    }
    const bin = this.resolveJuliaBin();
    const cmd = `${bin} --project=${this.compileEnv} --startup-file=no --history-file=no -e "import PackageCompiler; println(PackageCompiler.default_sysimg_path())"`;
    return (await execPromise(cmd)).stdout.trim();
  }
  async compileServerSysimg() {
    import_coc.window.showMessage(`PackageCompiler.jl will take about 5 mins to compile...`);
    const bin = this.resolveJuliaBin();
    await import_coc.workspace.createTerminal({name: "coc-julia-ls"}).then((t) => {
      const cmd = `${bin} --project=${this.compileEnv} ${import_path.default.join(this.compileEnv, "compile.jl")} -s ${this.lsProj} ${this.sysimgDir}`;
      t.sendText(cmd);
    });
  }
  async compileServerBin() {
    import_coc.window.showMessage(`PackageCompiler.jl will take about 10 mins to compile...`);
    const bin = this.resolveJuliaBin();
    await import_coc.workspace.createTerminal({name: "coc-julia-ls"}).then((t) => {
      const cmd = `${bin} --project=${this.compileEnv} ${import_path.default.join(this.compileEnv, "compile.jl")} -b ${this.lsProj} ${this.serverRoot}`;
      t.sendText(cmd);
    });
  }
  async prepareJuliaArgs() {
    const sysimg = await this.resolveSysimgPath();
    return ["--startup-file=no", "--history-file=no", `--sysimage=${sysimg}`, "--depwarn=no", `--project=${this.lsProj}`, this.mainJulia];
  }
  async prepareLSArgs() {
    const env = await this.resolveEnvPath();
    const depopPath = process.env.JULIA_DEPOT_PATH ? process.env.JULIA_DEPOT_PATH : "";
    return [env, "--debug=no", depopPath, this.context.storagePath];
  }
  async startServer() {
    await this.resolveMissingPkgs(this.compileEnv);
    let bin = import_path.default.join(this.serverRoot, "bin", process.platform === "win32" ? "JuliaLS.exe" : "JuliaLS");
    let args = await this.prepareLSArgs();
    if (!import_fs.default.existsSync(bin)) {
      await this.resolveMissingPkgs(this.lsProj);
      bin = this.resolveJuliaBin();
      const juliaArgs = await this.prepareJuliaArgs();
      args = juliaArgs.concat(args);
    }
    const tmpdir = await import_coc.workspace.nvim.eval("$TMPDIR");
    const serverOptions = {
      command: bin,
      args,
      options: {env: __spreadProps(__spreadValues({}, process.env), {TMPDIR: tmpdir})}
    };
    const clientOptions = {
      documentSelector: ["julia", "juliamarkdown"],
      initializationOptions: import_coc.workspace.getConfiguration("julia"),
      synchronize: {
        configurationSection: ["julia.lint", "julia.format"],
        fileEvents: import_coc.workspace.createFileSystemWatcher("**/*.{jl,jmd}")
      },
      progressOnInitialization: true,
      middleware: {
        provideCompletionItem: async (document, position, context, token, next) => {
          const option = context.option;
          const input = option.input.startsWith(option.word) ? option.input : option.word + option.input;
          const res = await next(document, position, context, token);
          const items = [];
          if (res && Array.isArray(res.items)) {
            for (const item of res.items) {
              if (item.textEdit && import_coc.TextEdit.is(item.textEdit) && (item.kind === 14 || item.kind === 17)) {
                const newText = item.textEdit.newText;
                if (!newText.startsWith(input)) {
                  const range = Object.assign({}, item.textEdit.range);
                  const start = import_coc.Position.create(range.start.line, range.start.character - input.length);
                  const end = import_coc.Position.create(range.end.line, range.end.character);
                  item.textEdit.newText = `${input}${newText}`;
                  item.textEdit.range = import_coc.Range.create(start, end);
                }
              }
              items.push(item);
            }
          }
          return {items, isIncomplete: res.isIncomplete};
        }
      }
    };
    const client = new import_coc.LanguageClient("julia", "Julia Language Server", serverOptions, clientOptions);
    this.context.subscriptions.push(import_coc.services.registLanguageClient(client));
  }
};

// src/index.ts
async function activate(context) {
  const ctx = new Ctx(context);
  if (!ctx.config.enabled)
    return;
  const bin = ctx.resolveJuliaBin();
  if (!bin) {
    import_coc2.window.showMessage(`Can't find julia`, "warning");
    return;
  }
  await ctx.startServer();
  context.subscriptions.push(import_coc2.commands.registerCommand("julia.CompileLanguageServerBin", async () => {
    await ctx.compileServerBin();
  }), import_coc2.commands.registerCommand("julia.CompileLanguageServerSysimg", async () => {
    await ctx.compileServerSysimg();
  }));
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
